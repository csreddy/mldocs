<apidoc:module name="GeospatialBuiltins" category="SearchBuiltins" subcategory="Geospatial" lib="cts" xmlns:apidoc="http://marklogic.com/xdmp/apidoc"><apidoc:summary access="public" category="SearchBuiltins" subcategory="Geospatial">
The geospatial built-in functions are XQuery functions defined to operate on
geospatial values.
</apidoc:summary><apidoc:function name="point" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a point value.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="latitude" type="xs:float">
     The latitude of the point.
  </apidoc:param>
      <apidoc:param name="longitude" type="xs:float">
     The longitude of the point.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:point(0.373899653086420E+02, -0.122078578406509E+03)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.point(0.373899653086420E+02, -0.122078578406509E+03);
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="point-latitude" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a point's latitude value.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="point" type="cts:point">
     The point.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:float</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $point := cts:point(37.270556, -118.672778)
  return
  cts:point-latitude($point)
=&gt;
37.27056
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var point = cts.point(37.270556, -118.672778);
cts.pointLatitude(point);
=&gt;
37.2705574035645
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="point-longitude" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a point's longitude value.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="point" type="cts:point">
     The point.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:float</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $point := cts:point(37.270556, -118.672778)
  return
  cts:point-longitude($point)
  =&gt;
  -118.6728
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var point = cts.point(37.270556, -118.672778);
cts.pointLongitude(point);
=&gt;
-118.672775268555
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="box" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a geospatial box value.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="south" type="xs:float">
    The southern boundary of the box.
  </apidoc:param>
      <apidoc:param name="west" type="xs:float">
    The western boundary of the box.
  </apidoc:param>
      <apidoc:param name="north" type="xs:float">
    The northern boundary of the box.
  </apidoc:param>
      <apidoc:param name="east" type="xs:float">
    The eastern boundary of the box.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:box</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:box(45, -122, 78, 30)
=&gt; [45, -122, 78, 30] (as a cts:box)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.box(45, -122, 78, 30);
=&gt; [45, -122, 78, 30] (as a cts.box)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="box-south" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a box's southern boundary.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="box" type="cts:box">
     The box.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:float</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:box-south(cts:box(45, -122, 78, 30))
=&gt; 45
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.boxSouth(cts.box(45, -122, 78, 30));
=&gt; 45
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="box-west" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a box's western boundary.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="box" type="cts:box">
     The box.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:float</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:box-west(cts:box(45, -122, 78, 30))
=&gt; -122
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.boxWest(cts.box(45, -122, 78, 30));
=&gt; -122
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="box-north" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a box's northern boundary.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="box" type="cts:box">
     The box.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:float</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:box-north(cts:box(45, -122, 78, 30))
=&gt; 78
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.boxNorth(cts.box(45, -122, 78, 30));
=&gt; 78
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="box-east" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a box's eastern boundary.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="box" type="cts:box">
     The box.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:float</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:box-east(cts:box(45, -122, 78, 30))
=&gt; 30
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.boxEast(cts.box(45, -122, 78, 30));
=&gt; 30
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="circle" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a geospatial circle value.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="radius" type="xs:double">
    The radius of the circle.  The units for the radius is determined at
    runtime by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> options (miles is currently the only
    option).
  </apidoc:param>
      <apidoc:param name="center" type="cts:point">
    A point representing the center of the circle.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:circle</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:circle(20, cts:point(37.655983, -122.425525))
=&gt; @20 37.655983,-122.42552 (as a cts:circle)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.circle(20, cts.point(37.655983, -122.425525));
=&gt; @20 37.655983,-122.42552 (as a cts.circle)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="circle-radius" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a circle's radius.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="circle" type="cts:circle">
     The circle.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:float</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:circle-radius(cts:circle(20, cts:point(37.655983, -122.425525)))
=&gt; 20
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.circleRadius(cts.circle(20, cts.point(37.655983, -122.425525)));
=&gt; 20
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="circle-center" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a circle's center point.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="circle" type="cts:circle">
     The circle.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:circle-center(cts:circle(20, cts:point(37.655983, -122.425525)))
=&gt; 37.655983, -122.425525 (as a cts:point)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.circleCenter(cts.circle(20, cts.point(37.655983, -122.425525)));
=&gt; 37.655983, -122.425525 (as a cts.point)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="polygon" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a geospatial polygon value.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="vertices" type="cts:point*">
    The vertices of the polygon, given in order. No edge may cover
    more than 180 degrees of either latitude or longitude.
    The polygon as a whole may not encompass both
    poles.  These constraints are necessary to ensure an unambiguous
    interpretation of the polygon. There must be at least three vertices.
    The first vertex should be identical to the last vertex to close the
    polygon.
    vertexes.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:polygon</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  (: this polygon approximates the 94041 zip code :)
  let $points := (cts:point(0.373899653086420E+02, -0.122078578406509E+03),
    cts:point(0.373765400000000E+02, -0.122063772000000E+03),
    cts:point(0.373781400000000E+02, -0.122067972000000E+03),
    cts:point(0.373825650000000E+02, -0.122068365000000E+03),
    cts:point(0.373797400000000E+02, -0.122072172000000E+03),
    cts:point(0.373899400000000E+02, -0.122092573000000E+03),
    cts:point(0.373941400000000E+02, -0.122095573000000E+03),
    cts:point(0.373966400000000E+02, -0.122094173000000E+03),
    cts:point(0.373958400000000E+02, -0.122092373000000E+03),
    cts:point(0.374004400000000E+02, -0.122091273000000E+03),
    cts:point(0.374004400000000E+02, -0.122091273000000E+03),
    cts:point(0.373873400000000E+02, -0.122057872000000E+03),
    cts:point(0.373873400000000E+02, -0.122057872000000E+03),
    cts:point(0.373854400000000E+02, -0.122052672000000E+03),
    cts:point(0.373833400000000E+02, -0.122053372000000E+03),
    cts:point(0.373819400000000E+02, -0.122057572000000E+03),
    cts:point(0.373775400000000E+02, -0.122060872000000E+03),
    cts:point(0.373765400000000E+02, -0.122063772000000E+03) )
  return
  cts:polygon($points)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// this polygon approximates the 94041 zip code 
var points = [cts.point(0.373899653086420E+02, -0.122078578406509E+03),
    cts.point(0.373765400000000E+02, -0.122063772000000E+03),
    cts.point(0.373781400000000E+02, -0.122067972000000E+03),
    cts.point(0.373825650000000E+02, -0.122068365000000E+03),
    cts.point(0.373797400000000E+02, -0.122072172000000E+03),
    cts.point(0.373899400000000E+02, -0.122092573000000E+03),
    cts.point(0.373941400000000E+02, -0.122095573000000E+03),
    cts.point(0.373966400000000E+02, -0.122094173000000E+03),
    cts.point(0.373958400000000E+02, -0.122092373000000E+03),
    cts.point(0.374004400000000E+02, -0.122091273000000E+03),
    cts.point(0.374004400000000E+02, -0.122091273000000E+03),
    cts.point(0.373873400000000E+02, -0.122057872000000E+03),
    cts.point(0.373873400000000E+02, -0.122057872000000E+03),
    cts.point(0.373854400000000E+02, -0.122052672000000E+03),
    cts.point(0.373833400000000E+02, -0.122053372000000E+03),
    cts.point(0.373819400000000E+02, -0.122057572000000E+03),
    cts.point(0.373775400000000E+02, -0.122060872000000E+03),
    cts.point(0.373765400000000E+02, -0.122063772000000E+03) ];
cts.polygon(points);
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="polygon-vertices" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a polygon's vertices.
  The first vertex and last vertex will always be the same.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="polygon" type="cts:polygon">
     The polygon.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $node :=
    &lt;polygon zip="94041"&gt;
       0.373899653086420E+02,       -0.122078578406509E+03
       0.373765400000000E+02,       -0.122063772000000E+03
       0.373781400000000E+02,       -0.122067972000000E+03
       0.373825650000000E+02,       -0.122068365000000E+03
       0.373797400000000E+02,       -0.122072172000000E+03
       0.373899400000000E+02,       -0.122092573000000E+03
       0.373941400000000E+02,       -0.122095573000000E+03
       0.373966400000000E+02,       -0.122094173000000E+03
       0.373958400000000E+02,       -0.122092373000000E+03
       0.374004400000000E+02,       -0.122091273000000E+03
       0.374004400000000E+02,       -0.122091273000000E+03
       0.373873400000000E+02,       -0.122057872000000E+03
       0.373873400000000E+02,       -0.122057872000000E+03
       0.373854400000000E+02,       -0.122052672000000E+03
       0.373833400000000E+02,       -0.122053372000000E+03
       0.373819400000000E+02,       -0.122057572000000E+03
       0.373775400000000E+02,       -0.122060872000000E+03
       0.373765400000000E+02,       -0.122063772000000E+03
    &lt;/polygon&gt;
    return
    cts:polygon-vertices(cts:polygon(fn:data($node)))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var points = [cts.point(0.373899653086420E+02, -0.122078578406509E+03),
    cts.point(0.373765400000000E+02, -0.122063772000000E+03),
    cts.point(0.373781400000000E+02, -0.122067972000000E+03),
    cts.point(0.373825650000000E+02, -0.122068365000000E+03),
    cts.point(0.373797400000000E+02, -0.122072172000000E+03),
    cts.point(0.373899400000000E+02, -0.122092573000000E+03),
    cts.point(0.373941400000000E+02, -0.122095573000000E+03),
    cts.point(0.373966400000000E+02, -0.122094173000000E+03),
    cts.point(0.373958400000000E+02, -0.122092373000000E+03),
    cts.point(0.374004400000000E+02, -0.122091273000000E+03),
    cts.point(0.374004400000000E+02, -0.122091273000000E+03),
    cts.point(0.373873400000000E+02, -0.122057872000000E+03),
    cts.point(0.373873400000000E+02, -0.122057872000000E+03),
    cts.point(0.373854400000000E+02, -0.122052672000000E+03),
    cts.point(0.373833400000000E+02, -0.122053372000000E+03),
    cts.point(0.373819400000000E+02, -0.122057572000000E+03),
    cts.point(0.373775400000000E+02, -0.122060872000000E+03),
    cts.point(0.373765400000000E+02, -0.122063772000000E+03) ];
cts.polygonVertices(cts.polygon(points));
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="linestring" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a geospatial linestring value.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="vertices" type="cts:point*">
    The waypoints of the linestring, given in order.
    vertexes.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:linestring</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $points := (cts:point(0.373899653086420E+02, -0.122078578406509E+03),
    cts:point(0.373765400000000E+02, -0.122063772000000E+03),
    cts:point(0.373781400000000E+02, -0.122067972000000E+03),
    cts:point(0.373825650000000E+02, -0.122068365000000E+03),
    cts:point(0.373797400000000E+02, -0.122072172000000E+03),
    cts:point(0.373899400000000E+02, -0.122092573000000E+03) )
  return
  cts:linestring($points)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var points = [cts.point(0.373899653086420E+02, -0.122078578406509E+03),
    cts.point(0.373765400000000E+02, -0.122063772000000E+03),
    cts.point(0.373781400000000E+02, -0.122067972000000E+03),
    cts.point(0.373825650000000E+02, -0.122068365000000E+03),
    cts.point(0.373797400000000E+02, -0.122072172000000E+03),
    cts.point(0.373899400000000E+02, -0.122092573000000E+03) ];
cts.linestring(points);
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="linestring-vertices" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a linestring's vertices.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="linestring" type="cts:linestring">
     The linestring.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $linestring :=
    "LINESTRING(
       0.373899653086420E+02 -0.122078578406509E+03,
       0.373765400000000E+02 -0.122063772000000E+03,
       0.373781400000000E+02 -0.122067972000000E+03,
       0.373825650000000E+02 -0.122068365000000E+03,
       0.373797400000000E+02 -0.122072172000000E+03,
       0.373899400000000E+02 -0.122092573000000E+03,
       0.373941400000000E+02 -0.122095573000000E+03,
       0.373966400000000E+02 -0.122094173000000E+03,
       0.373958400000000E+02 -0.122092373000000E+03,
       0.374004400000000E+02 -0.122091273000000E+03)"
    return
    cts:linestring-vertices(cts:linestring($linestring))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var points = [cts.point(0.373899653086420E+02, -0.122078578406509E+03),
    cts.point(0.373765400000000E+02, -0.122063772000000E+03),
    cts.point(0.373781400000000E+02, -0.122067972000000E+03),
    cts.point(0.373825650000000E+02, -0.122068365000000E+03),
    cts.point(0.373797400000000E+02, -0.122072172000000E+03),
    cts.point(0.373899400000000E+02, -0.122092573000000E+03) ];
var ls = cts.linestring(points);
cts.linestringVertices(ls);
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="complex-polygon" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a geospatial complex polygon value.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="outer" type="cts:polygon">
  The outer polygon.
  </apidoc:param>
      <apidoc:param name="inner" type="cts:polygon*">
  The innner (hole) polygons.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:complex-polygon</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:complex-polygon(
  cts:polygon("0,0 10,0 10,10 0,10 0,0"),
  cts:polygon("5,0 7,0 7,5 5,5 5,0"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.complexPolygon(
  cts.polygon("0,0 10,0 10,10 0,10 0,0"),
  cts.polygon("5,0 7,0 7,5 5,5 5,0"));
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="complex-polygon-outer" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a complex polygon's outer polygon.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="complexPolygon" type="cts:complex-polygon">
     The complex polygon.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:polygon?</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $node :=
    &lt;complexPolygon name="Arapahoe"&gt;POLYGON((
      0.396982870000000E+02 -0.104935135000000E+03,
      0.396965870000000E+02 -0.104938635000000E+03,
      0.396965870000000E+02 -0.104938635000000E+03,
      0.397110870000000E+02 -0.104931634000000E+03,
      0.397066870000000E+02 -0.104926934000000E+03,
      0.397012870000000E+02 -0.104932834000000E+03,
      0.396971870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104931534000000E+03,
      0.396966870000000E+02 -0.104934335000000E+03,
      0.396966870000000E+02 -0.104934335000000E+03,
      0.396981250000000E+02 -0.104934109000000E+03
      ),
       (
      0.396981250000000E+02 -0.104934109000000E+03,
      0.397001130000000E+02 -0.104931652000000E+03,
      0.397001870000000E+02 -0.104934034000000E+03,
      0.396981250000000E+02 -0.104934109000000E+03
       ))
    &lt;/complexPolygon&gt;
    return
    cts:complex-polygon-outer(cts:parse-wkt(fn:data($node)))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var node = {Arapahoe:"POLYGON(( \n\
            0.396982870000000E+02 -0.104935135000000E+03, \n\
            0.396965870000000E+02 -0.104938635000000E+03, \n\
            0.396965870000000E+02 -0.104938635000000E+03, \n\
            0.397110870000000E+02 -0.104931634000000E+03, \n\
            0.397066870000000E+02 -0.104926934000000E+03, \n\
            0.397012870000000E+02 -0.104932834000000E+03, \n\
            0.396971870000000E+02 -0.104928134000000E+03, \n\
            0.396965870000000E+02 -0.104928134000000E+03, \n\
            0.396965870000000E+02 -0.104928134000000E+03, \n\
            0.396965870000000E+02 -0.104931534000000E+03, \n\
            0.396966870000000E+02 -0.104934335000000E+03, \n\
            0.396966870000000E+02 -0.104934335000000E+03, \n\
            0.396981250000000E+02 -0.104934109000000E+03), \n\
            ( 0.396981250000000E+02 -0.104934109000000E+03, \n\
            0.397001130000000E+02 -0.104931652000000E+03, \n\
            0.397001870000000E+02 -0.104934034000000E+03, \n\
            0.396981250000000E+02 -0.104934109000000E+03))"};
cts.complexPolygonOuter(cts.parseWkt(node.Arapahoe));
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="complex-polygon-inner" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a complex polygon's inner polygons.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="complexPolygon" type="cts:complex-polygon">
     The complex polygon.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:polygon*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $node :=
    &lt;complexPolygon name="Arapahoe"&gt;POLYGON((
      0.396982870000000E+02 -0.104935135000000E+03,
      0.396965870000000E+02 -0.104938635000000E+03,
      0.396965870000000E+02 -0.104938635000000E+03,
      0.397110870000000E+02 -0.104931634000000E+03,
      0.397066870000000E+02 -0.104926934000000E+03,
      0.397012870000000E+02 -0.104932834000000E+03,
      0.396971870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104931534000000E+03,
      0.396966870000000E+02 -0.104934335000000E+03,
      0.396966870000000E+02 -0.104934335000000E+03,
      0.396981250000000E+02 -0.104934109000000E+03
      ),

       (
      0.396981250000000E+02 -0.104934109000000E+03,
      0.397001130000000E+02 -0.104931652000000E+03,
      0.397001870000000E+02 -0.104934034000000E+03,
      0.396981250000000E+02 -0.104934109000000E+03
       ))
    &lt;/complexPolygon&gt;
    return
    cts:complex-polygon-inner(cts:parse-wkt(fn:data($node)))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var node = {Arapahoe:"POLYGON(( \n\
            0.396982870000000E+02 -0.104935135000000E+03, \n\
            0.396965870000000E+02 -0.104938635000000E+03, \n\
            0.396965870000000E+02 -0.104938635000000E+03, \n\
            0.397110870000000E+02 -0.104931634000000E+03, \n\
            0.397066870000000E+02 -0.104926934000000E+03, \n\
            0.397012870000000E+02 -0.104932834000000E+03, \n\
            0.396971870000000E+02 -0.104928134000000E+03, \n\
            0.396965870000000E+02 -0.104928134000000E+03, \n\
            0.396965870000000E+02 -0.104928134000000E+03, \n\
            0.396965870000000E+02 -0.104931534000000E+03, \n\
            0.396966870000000E+02 -0.104934335000000E+03, \n\
            0.396966870000000E+02 -0.104934335000000E+03, \n\
            0.396981250000000E+02 -0.104934109000000E+03), \n\
            ( 0.396981250000000E+02 -0.104934109000000E+03, \n\
            0.397001130000000E+02 -0.104931652000000E+03, \n\
            0.397001870000000E+02 -0.104934034000000E+03, \n\
            0.396981250000000E+02 -0.104934109000000E+03))"};
cts.complexPolygonOuter(cts.parseWkt(node.Arapahoe));
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-geospatial-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching elements by name whose content
  represents a point contained within the given geographic box, circle, or
  polygon, or equal to the given point. Points that lie
  between the southern boundary and the northern boundary of a box,
  travelling northwards,
  and between the western boundary and the eastern boundary of the box,
  travelling eastwards, will match.
  Points contained within the given radius of the center point of a circle will
  match, using the curved distance on the surface of the Earth.
  Points contained within the given polygon will match, using great circle arcs
  over a spherical model of the Earth as edges.  An error may result
  if the polygon is malformed in some way.
  Points equal to the a given point will match, taking into account the fact
  that longitudes converge at the poles.
  Using the geospatial query constructors requires a valid geospatial
  license key; without a valid license key, searches that include
  geospatial queries will throw an exception.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*">
    One or more element QNames to match.
    When multiple QNames are specified,
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="regions" type="cts:region*">
    One or more geographic boxes, circles, polygons, or points. Where multiple
    regions are specified, the query matches if any region matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are counted as
         matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are not
	counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"type=long-lat-point"</dt>
        <dd>Specifies the format for the point in the data as longitude first,
        latitude second.</dd>
        <dt>"type=point"</dt>
        <dd>Specifies the format for the point in the data as latitude first,
        longitude second.  This is the default format.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $regions parameter are
        considered synonyms for scoring purposes.  The result is that
        occurances of more than one of the synonyms are scored as if
        there are more occurance of the same term (as opposed to
        having a separate term that contributes to score). </dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-geospatial-query</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">The point value is expressed in the content of the element as a pair
of numbers, separated by whitespace and punctuation (excluding decimal points
and sign characters).
</p>
<p xmlns="http://www.w3.org/1999/xhtml">Point values and boundary specifications of
boxes are given in degrees
relative to the WGS84 coordinate system.  Southern latitudes and Western
longitudes take negative values.  Longitudes will be wrapped to the range
(-180,+180) and latitudes will be clipped to the range (-90,+90).
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If the northern boundary of a box is south of the southern boundary, no
points will match. However, longitudes wrap around the globe, so that if
the western boundary is east of the eastern boundary,
then the box crosses the anti-meridian.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">Special handling occurs at the poles, as all longitudes exist at latitudes
+90 and -90.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope factor
  will provide useful results. Using a slope factor greater than 1 gives distinct
  scores over a smaller range of values, and produces generally higher scores.
  Using a slope factor less than 1 gives distinct scores over a wider range of
  values, and produces generally lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root&gt;
  &lt;item&gt;&lt;point&gt;10.5, 30.0&lt;/point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point&gt;15.35, 35.34&lt;/point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point&gt;5.11, 40.55&lt;/point&gt;&lt;/item&gt;
&lt;/root&gt; );

cts:search(doc("/points.xml")//item,
  cts:element-geospatial-query(xs:QName("point"), cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
  &lt;item&gt;&lt;point&gt;15.35, 35.34&lt;/point&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-geospatial-query(xs:QName("point"), cts:box(10.0, 40.0, 20.0, 35.0)))
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;point&gt;10.5, 30.0&lt;/point&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-geospatial-query(xs:QName("point"), cts:box(20.0, 35.0, 10.0, 40.0)))
(:
  throws an error (latitudes do not wrap)
:)
;
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// create documents with test data 
declareUpdate();
xdmp.documentInsert("/point1.xml", xdmp.unquote(
 ' &lt;item&gt;&lt;point&gt;10.5, 30.0&lt;/point&gt;&lt;/item&gt;' )),
		
xdmp.documentInsert("/point2.xml", xdmp.unquote(
 '  &lt;item&gt;&lt;point&gt;15.35, 35.34&lt;/point&gt;&lt;/item&gt;' )),

xdmp.documentInsert("/point3.xml", xdmp.unquote(
 '  &lt;item&gt;&lt;point&gt;5.11, 40.55&lt;/point&gt;&lt;/item&gt;' ));

******
// Now the following search:

cts.search(cts.elementGeospatialQuery(xs.QName("point"), 
                  cts.box(10.0, 35.0, 20.0, 40.0)));

=&gt; The /point2.xml document (because 
   &lt;point&gt;15.35, 35.34&lt;/point&gt; matches).

******
// And the following search:

cts.search(cts.elementGeospatialQuery(xs.QName("point"), 
                  cts.box(10.0, 40.0, 20.0, 35.0)));

=&gt; The /point1.xml document(wrapping around the Earth):

******
// And the following search:

cts.search(cts.elementGeospatialQuery(xs.QName("point"), 
                  cts.box(20.0, 35.0, 10.0, 40.0)));

=&gt; throws an XDMP-BADBOX error (because latitudes do not wrap)

</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="element-geospatial-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-geospatial-query(
    xs:QName("point"), cts:box(10.1, 10.2, 20.1, 20.2))
return
cts:element-geospatial-query-element-name($query)

=&gt; "point" (as an xs:QName)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementGeospatialQuery(
    xs.QName("point"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementGeospatialQueryElementName(query);

=&gt; "point" (as an xs.QName)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-geospatial-query-region" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the geographical regions
  with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:region*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-geospatial-query(
    xs:QName("point"), cts:box(10.1, 10.2, 20.1, 20.2))
return
cts:element-geospatial-query-region($query)

=&gt; cts:box("[10.1, 10.2, 20.1, 20.2]")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementGeospatialQuery(
    xs.QName("point"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementGeospatialQueryRegion(query);

=&gt; [10.1, 10.2, 20.1, 20.2]
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-geospatial-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-geospatial-query(
    xs:QName("point"), cts:box(10.1, 10.2, 20.1, 20.2))
return
cts:element-geospatial-query-options($query)

=&gt; coordinate-system=wgs84
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementGeospatialQuery(
    xs.QName("point"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementGeospatialQueryOptions(query);

=&gt; coordinate-system=wgs84
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-geospatial-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-geospatial-query(
    xs:QName("point"), cts:box(10.1, 10.2, 20.1, 20.2))
return
cts:element-geospatial-query-weight($query)

=&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementGeospatialQuery(
    xs.QName("point"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementGeospatialQueryWeight(query);

=&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-geospatial-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching json properties by name whose content
  represents a point contained within the given geographic box, circle, or
  polygon, or equal to the given point. Points that lie
  between the southern boundary and the northern boundary of a box,
  travelling northwards,
  and between the western boundary and the eastern boundary of the box,
  travelling eastwards, will match.
  Points contained within the given radius of the center point of a circle will
  match, using the curved distance on the surface of the Earth.
  Points contained within the given polygon will match, using great circle arcs
  over a spherical model of the Earth as edges.  An error may result
  if the polygon is malformed in some way.
  Points equal to the a given point will match, taking into account the fact
  that longitudes converge at the poles.
  Using the geospatial query constructors requires a valid geospatial
  license key; without a valid license key, searches that include
  geospatial queries will throw an exception.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="property-name" type="xs:string*">
    One or more json property names to match.
    When multiple names are specified,
    the query matches if any name matches.
  </apidoc:param>
      <apidoc:param name="regions" type="cts:region*">
    One or more geographic boxes, circles, polygons, or points. Where multiple
    regions are specified, the query matches if any region matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are counted as
         matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are not
  counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"type=long-lat-point"</dt>
        <dd>Specifies the format for the point in the data as longitude first,
        latitude second.</dd>
        <dt>"type=point"</dt>
        <dd>Specifies the format for the point in the data as latitude first,
        longitude second.  This is the default format.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $regions parameter are
        considered synonyms for scoring purposes.  The result is that
        occurances of more than one of the synonyms are scored as if
        there are more occurance of the same term (as opposed to
        having a separate term that contributes to score). </dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:json-property-geospatial-query</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">The point value is expressed in the content of the element as a pair
of numbers, separated by whitespace and punctuation (excluding decimal points
and sign characters).
</p>
<p xmlns="http://www.w3.org/1999/xhtml">Point values and boundary specifications of
boxes are given in degrees
relative to the WGS84 coordinate system.  Southern latitudes and Western
longitudes take negative values.  Longitudes will be wrapped to the range
(-180,+180) and latitudes will be clipped to the range (-90,+90).
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If the northern boundary of a box is south of the southern boundary, no
points will match. However, longitudes wrap around the globe, so that if
the western boundary is east of the eastern boundary,
then the box crosses the anti-meridian.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">Special handling occurs at the poles, as all longitudes exist at latitudes
+90 and -90.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope factor
  will provide useful results. Using a slope factor greater than 1 gives distinct
  scores over a smaller range of values, and produces generally higher scores.
  Using a slope factor less than 1 gives distinct scores over a wider range of
  values, and produces generally lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: create a document with test data :)
xdmp:document-insert("/points.json",
object-node {
  "item" : object-node {
    "point" : "15.35, 35.34"
  }
});

cts:search(doc("/points.json")//item,
  cts:json-property-geospatial-query("point", cts:box(10.0, 35.0, 20.0, 40.0)));
(:
  returns the following node:  {"point":"15.35, 35.34"}
:)

cts:search(doc("/points.json")//item,
  cts:json-property-geospatial-query("point", cts:box(12.0, 20.0, 20.0, 35.0)));
(:
  returns ()
:)

</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// create a document with test data 
declareUpdate();
xdmp.documentInsert("/points.json",
 {"item" : {
    "point" : "15.35, 35.34" }
 });

******
// Now you can run the following search:

cts.search(cts.jsonPropertyGeospatialQuery("point", 
		cts.box(10.0, 35.0, 20.0, 40.0)));

=&gt;
  returns the following document:  
  {"item":{"point":"15.35, 35.34"}}

******
// And the following search:

cts.search(cts.jsonPropertyGeospatialQuery("point", 
		cts.box(12.0, 20.0, 20.0, 35.0)));

=&gt; returns ()


</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="json-property-geospatial-query-property-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the json property names used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-geospatial-query("point", 
   cts:box(10.1, 10.2, 20.1, 20.2))
return
cts:json-property-geospatial-query-property-name($query)
  
=&gt; "point"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyGeospatialQuery("point", 
   cts.box(10.1, 10.2, 20.1, 20.2))
cts.jsonPropertyGeospatialQueryPropertyName(query);
  
=&gt; "point"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-geospatial-query-region" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the geographical regions
  with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:region*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-geospatial-query("point", 
   cts:box(10.1, 10.2, 20.1, 20.2))
return
cts:json-property-geospatial-query-region($query)
  
=&gt; cts:box("[10.1, 10.2, 20.1, 20.2]")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyGeospatialQuery("point", 
   cts.box(10.1, 10.2, 20.1, 20.2));
cts.jsonPropertyGeospatialQueryRegion(query);
  
=&gt; [10.1, 10.2, 20.1, 20.2]
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-geospatial-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-geospatial-query("point", 
   cts:box(10.1, 10.2, 20.1, 20.2))
return
cts:json-property-geospatial-query-options($query)
  
=&gt; coordinate-system=wgs84
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyGeospatialQuery("point", 
   cts.box(10.1, 10.2, 20.1, 20.2));
cts.jsonPropertyGeospatialQueryOptions(query);
  
=&gt; coordinate-system=wgs84
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-geospatial-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-geospatial-query("point", 
   cts:box(10.1, 10.2, 20.1, 20.2))
return
cts:json-property-geospatial-query-weight($query)
  
=&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyGeospatialQuery("point", 
   cts.box(10.1, 10.2, 20.1, 20.2));
cts.jsonPropertyGeospatialQueryWeight(query);
  
=&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-child-geospatial-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching elements by name which has
  specific element children representing latitude and longitude values for
  a point contained within the given geographic box, circle, or polygon, or
  equal to the given point.  Points that lie
  between the southern boundary and the northern boundary of a box,
  travelling northwards,
  and between the western boundary and the eastern boundary of the box,
  travelling eastwards, will match.
  Points contained within the given radius of the center point of a circle will
  match, using the curved distance on the surface of the Earth.
  Points contained within the given polygon will match, using great circle arcs
  over a spherical model of the Earth as edges.  An error may result
  if the polygon is malformed in some way.
  Points equal to the a given point will match, taking into account the fact
  that longitudes converge at the poles.
  Using the geospatial query constructors requires a valid geospatial
  license key; without a valid license key, searches that include
  geospatial queries will throw an exception.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="parent-element-name" type="xs:QName*">
    One or more parent element QNames to match.
    When multiple QNames are specified,
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="child-element-names" type="xs:QName*">
    One or more child element QNames to match.
    When multiple QNames are specified, the query matches
    if any QName matches; however, only the first matching latitude
    child in any point instance will be checked.  The element must specify
    both latitude and longitude coordinates.
  </apidoc:param>
      <apidoc:param name="regions" type="cts:region*">
    One or more geographic boxes, circles, polygons, or points. Where multiple
    regions are specified, the query matches if any region matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are counted
         as matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are not
	counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"type=long-lat-point"</dt>
        <dd>Specifies the format for the point in the data as longitude first,
        latitude second.</dd>
        <dt>"type=point"</dt>
        <dd>Specifies the format for the point in the data as latitude first,
        longitude second.  This is the default format.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $regions parameter are
        considered synonyms for scoring purposes.  The result is that
        occurances of more than one of the synonyms are scored as if
        there are more occurance of the same term (as opposed to
        having a separate term that contributes to score). </dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-child-geospatial-query</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">The point value is expressed in the content of the element as a child
of numbers, separated by whitespace and punctuation (excluding decimal points
and sign characters).
</p>
<p xmlns="http://www.w3.org/1999/xhtml">Point values and boundary specifications of boxes are given in degrees
relative to the WGS84 coordinate system.  Southern latitudes and Western
longitudes take negative values.  Longitudes will be wrapped to the range
(-180,+180) and latitudes will be clipped to the range (-90,+90).
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If the northern boundary of a box is south of the southern boundary, no
points will  match. However, longitudes wrap around the globe, so that if
the western boundary is east of the eastern boundary,
then the box crosses the anti-meridian.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">Special handling occurs at the poles, as all longitudes exist at latitudes
+90 and -90.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope factor
  will provide useful results. Using a slope factor greater than 1 gives distinct
  scores over a smaller range of values, and produces generally higher scores.
  Using a slope factor less than 1 gives distinct scores over a wider range of
  values, and produces generally lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root&gt;
  &lt;item&gt;&lt;point&gt;&lt;pos&gt;10.5 30.0&lt;/pos&gt;&lt;/point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point&gt;&lt;pos&gt;15.35 35.34&lt;/pos&gt;&lt;/point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point&gt;&lt;pos&gt;5.11 40.55&lt;/pos&gt;&lt;/point&gt;&lt;/item&gt;
&lt;/root&gt; );

cts:search(doc("/points.xml")//item,
  cts:element-child-geospatial-query(xs:QName("point"), xs:QName("pos"),
    cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
  &lt;item&gt;&lt;point&gt;&lt;pos&gt;15.35 35.34&lt;/pos&gt;&lt;/point&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-child-geospatial-query(xs:QName("point"), xs:QName("pos"),
    cts:box(10.0, 40.0, 20.0, 35.0)))
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;point&gt;&lt;pos&gt;10.5 30.0&lt;/pos&gt;&lt;/point&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-child-geospatial-query(xs:QName("point"), xs:QName("pos"),
    cts:box(20.0, 35.0, 10.0, 40.0)))
(:
  throws an error (latitudes do not wrap)
:)
;
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// create a document with test data 
declareUpdate();
xdmp.documentInsert("/point01.xml", xdmp.unquote(
 ' &lt;item&gt;&lt;point&gt;&lt;pos&gt;10.5, 30.0&lt;/pos&gt;&lt;/point&gt;&lt;/item&gt;' )),
		
xdmp.documentInsert("/point02.xml", xdmp.unquote(
 '  &lt;item&gt;&lt;point&gt;&lt;pos&gt;15.35, 35.34&lt;/pos&gt;&lt;/point&gt;&lt;/item&gt;' )),

xdmp.documentInsert("/point03.xml", xdmp.unquote(
 '  &lt;item&gt;&lt;point&gt;&lt;pos&gt;5.11, 40.55&lt;/pos&gt;&lt;/point&gt;&lt;/item&gt;' ));

******
// Now the following search:

cts.search(cts.elementChildGeospatialQuery(xs.QName("point"), 
		  xs.QName("pos"), 
                  cts.box(10.0, 35.0, 20.0, 40.0)));

=&gt; The /point02.xml document (because 
   &lt;point&gt;15.35, 35.34&lt;/point&gt; matches).

******
// And the following search:

cts.search(cts.elementChildGeospatialQuery(xs.QName("point"), 
		  xs.QName("pos"),
                  cts.box(10.0, 40.0, 20.0, 35.0)));

=&gt; The /point01.xml document(wrapping around the Earth):

******
// And the following search:

cts.search(cts.elementChildGeospatialQuery(xs.QName("point"), 
		  xs.QName("pos"),
                  cts.box(20.0, 35.0, 10.0, 40.0)));

=&gt; throws an XDMP-BADBOX error (because latitudes do not wrap)

</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="element-child-geospatial-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-child-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-child-geospatial-query(
     xs:QName("point"), xs:QName("pos"),
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-child-geospatial-query-element-name($query)
  
=&gt; "point" (as an xs:QName)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementChildGeospatialQuery(
     xs.QName("point"), xs.QName("pos"),
     cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementChildGeospatialQueryElementName(query);
  
=&gt; "point" (as an xs.QName)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-child-geospatial-query-child-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-child-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-child-geospatial-query(
     xs:QName("point"), xs:QName("pos"),
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-child-geospatial-query-child-name($query)
  
=&gt; "pos" (as an xs:QName)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementChildGeospatialQuery(
     xs.QName("point"), xs.QName("pos"),
     cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementChildGeospatialQueryChildName(query);
  
=&gt; "pos" (as an xs.QName)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-child-geospatial-query-region" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the geographical regions with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-child-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:region*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-child-geospatial-query(
     xs:QName("point"), xs:QName("pos"),
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-child-geospatial-query-region($query)
  
=&gt; cts:box("[10.1, 10.2, 20.1, 20.2]")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementChildGeospatialQuery(
     xs.QName("point"), xs.QName("pos"),
     cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementChildGeospatialQueryRegion(query);
  
=&gt; [10.1, 10.2, 20.1, 20.2]
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-child-geospatial-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-child-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-child-geospatial-query(
     xs:QName("point"), xs:QName("pos"),
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-child-geospatial-query-options($query)
  
=&gt; coordinate-system=wgs84
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementChildGeospatialQuery(
     xs.QName("point"), xs.QName("pos"),
     cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementChildGeospatialQueryOptions(query);
  
=&gt; coordinate-system=wgs84
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-child-geospatial-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-child-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-child-geospatial-query(
     xs:QName("point"), xs:QName("pos"),
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-child-geospatial-query-weight($query)
  
=&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementChildGeospatialQuery(
     xs.QName("point"), xs.QName("pos"),
     cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementChildGeospatialQueryWeight(query);
  
=&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-child-geospatial-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching json properties by name which has
  specific children representing latitude and longitude values for
  a point contained within the given geographic box, circle, or polygon, or
  equal to the given point.  Points that lie
  between the southern boundary and the northern boundary of a box,
  travelling northwards,
  and between the western boundary and the eastern boundary of the box,
  travelling eastwards, will match.
  Points contained within the given radius of the center point of a circle will
  match, using the curved distance on the surface of the Earth.
  Points contained within the given polygon will match, using great circle arcs
  over a spherical model of the Earth as edges.  An error may result
  if the polygon is malformed in some way.
  Points equal to the a given point will match, taking into account the fact
  that longitudes converge at the poles.
  Using the geospatial query constructors requires a valid geospatial
  license key; without a valid license key, searches that include
  geospatial queries will throw an exception.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="parent-property-name" type="xs:string*">
    One or more parent property names to match.
    When multiple names are specified,
    the query matches if any name matches.
  </apidoc:param>
      <apidoc:param name="child-property-names" type="xs:string*">
    One or more child property names to match.
    When multiple names are specified, the query matches
    if any name matches; however, only the first matching latitude
    child in any point instance will be checked.  The property must specify
    both latitude and longitude coordinates.
  </apidoc:param>
      <apidoc:param name="regions" type="cts:region*">
    One or more geographic boxes, circles, polygons, or points. Where multiple
    regions are specified, the query matches if any region matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are counted
         as matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are not
  counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"type=long-lat-point"</dt>
        <dd>Specifies the format for the point in the data as longitude first,
        latitude second.</dd>
        <dt>"type=point"</dt>
        <dd>Specifies the format for the point in the data as latitude first,
        longitude second.  This is the default format.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $regions parameter are
        considered synonyms for scoring purposes.  The result is that
        occurances of more than one of the synonyms are scored as if
        there are more occurance of the same term (as opposed to
        having a separate term that contributes to score). </dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:json-property-child-geospatial-query</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">The point value is expressed in the content of the property as a child
of numbers, separated by whitespace and punctuation (excluding decimal points
and sign characters).
</p>
<p xmlns="http://www.w3.org/1999/xhtml">Point values and boundary specifications of boxes are given in degrees
relative to the WGS84 coordinate system.  Southern latitudes and Western
longitudes take negative values.  Longitudes will be wrapped to the range
(-180,+180) and latitudes will be clipped to the range (-90,+90).
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If the northern boundary of a box is south of the southern boundary, no
points will  match. However, longitudes wrap around the globe, so that if
the western boundary is east of the eastern boundary,
then the box crosses the anti-meridian.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">Special handling occurs at the poles, as all longitudes exist at latitudes
+90 and -90.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope 
  factor will provide useful results. Using a slope factor greater than 
  1 gives distinct scores over a smaller range of values, and produces 
  generally higher scores.  Using a slope factor less than 1 gives distinct 
  scores over a wider range of values, and produces generally lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: create a document with test data :)
xdmp:document-insert("/points.json",
object-node {
  "item" : object-node {
    "point" : object-node {
      "pos" : "15.35, 35.34"
    }
  }
});

cts:search(doc("/points.json")//item,
  cts:json-property-child-geospatial-query("point", "pos",
    cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node: {"point":{"pos":"15.35, 35.34"}}
:)
;

cts:search(doc("/points.json")//item,
  cts:json-property-geospatial-query("point", cts:box(12.0, 20.0, 20.0, 35.0)));
(:
  returns ()
:)
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// create a document with test data 
declareUpdate();
xdmp.documentInsert("/points.json",
  { "item" :  { 
      "point" :  {
         "pos" : "15.35, 35.34"
    } } });

*******
// Now the following search:

cts.search(
  cts.jsonPropertyChildGeospatialQuery("point", "pos",
    cts.box(10.0, 35.0, 20.0, 40.0)))

=&gt; returns the document inserted: {"item":{"point":{"pos":"15.35, 35.34"}}}

******
// And the following search:

cts.search(
  cts.jsonPropertyGeospatialQuery("point", 
	  cts.box(12.0, 20.0, 20.0, 35.0)));

=&gt;  returns ()

</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="json-property-child-geospatial-query-property-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the names used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-child-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-child-geospatial-query("point", "pos",
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:json-property-child-geospatial-query-property-name($query)
  
=&gt; "point"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyChildGeospatialQuery("point", "pos",
     cts.box(10.1, 10.2, 20.1, 20.2));
cts.jsonPropertyChildGeospatialQueryPropertyName(query);
  
=&gt; "point"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-child-geospatial-query-child-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the names used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-child-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-child-geospatial-query("point", "pos",
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:json-property-child-geospatial-query-child-name($query)
  
=&gt; "pos"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyChildGeospatialQuery("point", "pos",
     cts.box(10.1, 10.2, 20.1, 20.2));
cts.jsonPropertyChildGeospatialQueryChildName(query);
  
=&gt; "pos"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-child-geospatial-query-region" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the geographical regions with which the specified query was 
  constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-child-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:region*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-child-geospatial-query("point", "pos",
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:json-property-child-geospatial-query-region($query)
  
=&gt; cts:box("[10.1, 10.2, 20.1, 20.2]")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyChildGeospatialQuery("point", "pos",
     cts.box(10.1, 10.2, 20.1, 20.2));
cts.jsonPropertyChildGeospatialQueryRegion(query);
  
=&gt; [10.1, 10.2, 20.1, 20.2]
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-child-geospatial-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-child-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-child-geospatial-query("point", "pos",
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:json-property-child-geospatial-query-Options($query)
  
=&gt; coordinate-system=wgs84
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyChildGeospatialQuery("point", "pos",
     cts.box(10.1, 10.2, 20.1, 20.2));
cts.jsonPropertyChildGeospatialQueryOptions(query);
  
=&gt; coordinate-system=wgs84
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-child-geospatial-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-child-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-child-geospatial-query("point", "pos",
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:json-property-child-geospatial-query-Weight($query)
  
=&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyChildGeospatialQuery("point", "pos",
     cts.box(10.1, 10.2, 20.1, 20.2));
cts.jsonPropertyChildGeospatialQueryWeight(query);
  
=&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-pair-geospatial-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching elements by name which has
  specific element children representing latitude and longitude values for
  a point contained within the given geographic box, circle, or polygon, or
  equal to the given point.
  Points that lie
  between the southern boundary and the northern boundary of a box,
  travelling northwards,
  and between the western boundary and the eastern boundary of the box,
  travelling eastwards, will match.
  Points contained within the given radius of the center point of a circle will
  match, using the curved distance on the surface of the Earth.
  Points contained within the given polygon will match, using great circle arcs
  over a spherical model of the Earth as edges.  An error may result
  if the polygon is malformed in some way.
  Points equal to the a given point will match, taking into account the fact
  that longitudes converge at the poles.
  Using the geospatial query constructors requires a valid geospatial
  license key; without a valid license key, searches that include
  geospatial queries will throw an exception.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*">
    One or more parent element QNames to match.
    When multiple QNames are specified,
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="latitude-element-names" type="xs:QName*">
    One or more latitude element QNames to match.
    When multiple QNames are specified, the query matches
    if any QName matches; however, only the first matching latitude
    child in any point instance will be checked.
  </apidoc:param>
      <apidoc:param name="longitude-element-names" type="xs:QName*">
    One or more longitude element QNames to match.
    When multiple QNames are specified, the query matches
    if any QName matches; however, only the first matching longitude
    child in any point instance will be checked.
  </apidoc:param>
      <apidoc:param name="regions" type="cts:region*">
    One or more geographic boxes, circles, polygons, or points. Where multiple
    regions are specified, the query matches if any region matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are counted
        as matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are not
	counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $regions parameter are
        considered synonyms for scoring purposes.  The result is that
        occurances of more than one of the synonyms are scored as if
        there are more occurance of the same term (as opposed to
        having a separate term that contributes to score). </dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-pair-geospatial-query</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">The point value is expressed in the content of the latitude and 
longitude elements (the latitude value in the latitude element, and the 
longitude value in the longitude element).
</p>
<p xmlns="http://www.w3.org/1999/xhtml">Point values and boundary specifications of boxes are given in degrees
relative to the WGS84 coordinate system.  Southern latitudes and Western
longitudes take negative values.  Longitudes will be wrapped to the range
(-180,+180) and latitudes will be clipped to the range (-90,+90).
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If the northern boundary of a box is south of the southern boundary, no
points will  match. However, longitudes wrap around the globe, so that if
the western boundary is east of the eastern boundary,
then the box crosses the anti-meridian.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">Special handling occurs at the poles, as all longitudes exist at latitudes
+90 and -90.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope factor
  will provide useful results. Using a slope factor greater than 1 gives 
  distinct scores over a smaller range of values, and produces generally 
  higher scores.  Using a slope factor less than 1 gives distinct scores 
  over a wider range of values, and produces generally lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root&gt;
  &lt;item&gt;&lt;point&gt;&lt;lat&gt;10.5&lt;/lat&gt;&lt;long&gt;30.0&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point&gt;&lt;lat&gt;15.35&lt;/lat&gt;&lt;long&gt;35.34&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point&gt;&lt;lat&gt;5.11&lt;/lat&gt;&lt;long&gt;40.55&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;
&lt;/root&gt; );

cts:search(doc("/points.xml")//item,
  cts:element-pair-geospatial-query(xs:QName("point"),
    xs:QName("lat"), xs:QName("long"), cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
  &lt;item&gt;&lt;point&gt;&lt;lat&gt;15.35&lt;/lat&gt;&lt;long&gt;35.34&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-pair-geospatial-query(xs:QName("point"),
    xs:QName("lat"), xs:QName("long"), cts:box(10.0, 40.0, 20.0, 35.0)))
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;point&gt;&lt;lat&gt;10.5&lt;/lat&gt;&lt;long&gt;30.0&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-pair-geospatial-query(xs:QName("point"),
    xs:QName("lat"), xs:QName("long"), cts:box(20.0, 35.0, 10.0, 40.0)))
(:
  throws an error (latitudes do not wrap)
:)
;
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// create documents with test data 
declareUpdate();
xdmp.documentInsert("/point01.xml", xdmp.unquote(
 ' &lt;item&gt;&lt;point&gt;&lt;lat&gt;10.5&lt;/lat&gt;&lt;long&gt;30.0&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;' )),
		
xdmp.documentInsert("/point02.xml", xdmp.unquote(
 '  &lt;item&gt;&lt;point&gt;&lt;lat&gt;15.35&lt;/lat&gt;&lt;long&gt;35.34&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;' )),

xdmp.documentInsert("/point03.xml", xdmp.unquote(
 '  &lt;item&gt;&lt;point&gt;&lt;lat&gt;5.11&lt;/lat&gt;&lt;long&gt;40.55&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;' ));

******
// Now the following search:

cts.search(
  cts.elementPairGeospatialQuery(xs.QName("point"),
    xs.QName("lat"), xs.QName("long"), cts.box(10.0, 35.0, 20.0, 40.0)));

=&gt; returns /point02.xml:
   &lt;item&gt;&lt;point&gt;&lt;lat&gt;15.35&lt;/lat&gt;&lt;long&gt;35.34&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;

******
// And the following search:

cts.search(
  cts.elementPairGeospatialQuery(xs.QName("point"),
    xs.QName("lat"), xs.QName("long"), cts.box(10.0, 40.0, 20.0, 35.0)));

=&gt;  returns /point01.xml (wrapping around the Earth):
    &lt;item&gt;&lt;point&gt;&lt;lat&gt;10.5&lt;/lat&gt;&lt;long&gt;30.0&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;
:)
;

cts.search(
  cts.elementPairGeospatialQuery(xs.QName("point"),
    xs.QName("lat"), xs.QName("long"), cts.box(20.0, 35.0, 10.0, 40.0)));

=&gt; throws an XDMP-BADBOX error (because latitudes do not wrap)
</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="element-pair-geospatial-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-pair-geospatial-query-element-name($query)
  
=&gt; "point" (as an xs:QName)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementPairGeospatialQuery(xs.QName("point"),
     xs.QName("lat"), xs.QName("long"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementPairGeospatialQueryElementName(query);
  
=&gt; "point" (as an xs.QName)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-pair-geospatial-query-latitude-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-pair-geospatial-query-latitude-name($query)
  
=&gt; "lat" (as an xs:QName)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementPairGeospatialQuery(xs.QName("point"),
     xs.QName("lat"), xs.QName("long"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementPairGeospatialQueryLatitudeName(query);
  
=&gt; "lat" (as an xs.QName)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-pair-geospatial-query-longitude-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-pair-geospatial-query-longitude-name($query)
  
=&gt; "long" (as an xs:QName)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementPairGeospatialQuery(xs.QName("point"),
     xs.QName("lat"), xs.QName("long"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementPairGeospatialQueryLongitudeName(query);
  
=&gt; "long" (as an xs.QName)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-pair-geospatial-query-region" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the geographical regions with which the specified query was 
  constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:region*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-pair-geospatial-query-region($query)
  
=&gt; cts:box("[10.1, 10.2, 20.1, 20.2]")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementPairGeospatialQuery(xs.QName("point"),
     xs.QName("lat"), xs.QName("long"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementPairGeospatialQueryRegion(query);
  
=&gt; [10.1, 10.2, 20.1, 20.2]
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-pair-geospatial-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-pair-geospatial-query-options($query)
  
=&gt; coordinate-system=wgs84
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementPairGeospatialQuery(xs.QName("point"),
     xs.QName("lat"), xs.QName("long"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementPairGeospatialQueryOptions(query);
  
=&gt; coordinate-system=wgs84
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-pair-geospatial-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-pair-geospatial-query-weight($query)
  
=&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementPairGeospatialQuery(xs.QName("point"),
     xs.QName("lat"), xs.QName("long"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementPairGeospatialQueryWeight(query);
  
=&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-pair-geospatial-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching json properties by name which has
  specific property children representing latitude and longitude values for
  a point contained within the given geographic box, circle, or polygon, or
  equal to the given point.
  Points that lie
  between the southern boundary and the northern boundary of a box,
  travelling northwards,
  and between the western boundary and the eastern boundary of the box,
  travelling eastwards, will match.
  Points contained within the given radius of the center point of a circle will
  match, using the curved distance on the surface of the Earth.
  Points contained within the given polygon will match, using great circle arcs
  over a spherical model of the Earth as edges.  An error may result
  if the polygon is malformed in some way.
  Points equal to the a given point will match, taking into account the fact
  that longitudes converge at the poles.
  Using the geospatial query constructors requires a valid geospatial
  license key; without a valid license key, searches that include
  geospatial queries will throw an exception.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="property-name" type="xs:string*">
    One or more parent property names to match.
    When multiple names are specified,
    the query matches if any name matches.
  </apidoc:param>
      <apidoc:param name="latitude-property-names" type="xs:string*">
    One or more latitude property names to match.
    When multiple names are specified, the query matches
    if any name matches; however, only the first matching latitude
    child in any point instance will be checked.
  </apidoc:param>
      <apidoc:param name="longitude-property-names" type="xs:string*">
    One or more longitude property names to match.
    When multiple names are specified, the query matches
    if any name matches; however, only the first matching longitude
    child in any point instance will be checked.
  </apidoc:param>
      <apidoc:param name="regions" type="cts:region*">
    One or more geographic boxes, circles, polygons, or points. Where multiple
    regions are specified, the query matches if any region matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are counted
        as matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are not
  counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as
  matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $regions parameter are
        considered synonyms for scoring purposes.  The result is that
        occurances of more than one of the synonyms are scored as if
        there are more occurance of the same term (as opposed to
        having a separate term that contributes to score). </dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:json-property-pair-geospatial-query</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">Point values and boundary specifications of boxes are given in degrees
relative to the WGS84 coordinate system.  Southern latitudes and Western
longitudes take negative values.  Longitudes will be wrapped to the range
(-180,+180) and latitudes will be clipped to the range (-90,+90).
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If the northern boundary of a box is south of the southern boundary, no
points will  match. However, longitudes wrap around the globe, so that if
the western boundary is east of the eastern boundary,
then the box crosses the anti-meridian.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">Special handling occurs at the poles, as all longitudes exist at latitudes
+90 and -90.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope factor
  will provide useful results. Using a slope factor greater than 1 gives 
  distinct scores over a smaller range of values, and produces generally 
  higher scores.  Using a slope factor less than 1 gives distinct scores 
  over a wider range of values, and produces generally lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: create a document with test data :)
xdmp:document-insert("/points.json",
object-node {
  "item" : object-node {
    "point" : object-node {
       "lat" : 15.35,
       "long" : 35.34
    }
  }
});

cts:search(doc("/points.json")//item,
  cts:json-property-pair-geospatial-query("point",
    "lat", "long", cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
:)
;

cts:search(doc("/points.json")//item,
  cts:json-property-pair-geospatial-query("point",
    "lat", "long", cts:box(12.0, 20.0, 20.0, 35.0)))
(:
  returns ()
:)
;
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// create a document with test data 
declareUpdate();
xdmp.documentInsert("/points.json",
{ "item" :  {
    "point" : {
       "lat" : 15.35,
       "long" : 35.34
    }
  }
});

*******
// Now the following search:

cts.search(
  cts.jsonPropertyPairGeospatialQuery("point",
    "lat", "long", cts.box(10.0, 35.0, 20.0, 40.0)));

=&gt;  returns the document inserted above:
    {"item":{"point":{"lat":15.35,"long":35.34}}}

*******
// And the following search:

cts.search(
  cts.jsonPropertyPairGeospatialQuery("point",
    "lat", "long", cts.box(12.0, 20.0, 20.0, 35.0)));

=&gt;  returns ()
</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="json-property-pair-geospatial-query-property-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the property names used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-pair-geospatial-query("point",
     "lat", "long", cts:box(10.1, 10.2, 20.1, 20.2))
return cts:json-property-pair-geospatial-query-property-name($query)
  
=&gt; "point"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyPairGeospatialQuery("point",
     "lat", "long", cts.box(10.1, 10.2, 20.1, 20.2));
cts.jsonPropertyPairGeospatialQueryPropertyName(query);
  
=&gt; "point"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-pair-geospatial-query-latitude-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the property names used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-pair-geospatial-query("point",
     "lat", "long", cts:box(10.1, 10.2, 20.1, 20.2))
return cts:json-property-pair-geospatial-query-latitude-name($query)
  
=&gt; "lat"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyPairGeospatialQuery("point",
     "lat", "long", cts.box(10.1, 10.2, 20.1, 20.2));
cts.jsonPropertyPairGeospatialQueryLatitudeName(query);
  
=&gt; "lat"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-pair-geospatial-query-longitude-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the property names used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-pair-geospatial-query("point",
     "lat", "long", cts:box(10.1, 10.2, 20.1, 20.2))
return cts:json-property-pair-geospatial-query-longitude-name($query)
  
=&gt; "long"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyPairGeospatialQuery("point",
     "lat", "long", cts.box(10.1, 10.2, 20.1, 20.2));
cts.jsonPropertyPairGeospatialQueryLongitudeName(query);
  
=&gt; "long"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-pair-geospatial-query-region" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the geographical regions with which the specified query was 
  constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:region*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-pair-geospatial-query("point",
     "lat", "long", cts:box(10.1, 10.2, 20.1, 20.2))
return cts:json-property-pair-geospatial-query-region($query)
  
=&gt; cts:box("[10.1, 10.2, 20.1, 20.2]")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyPairGeospatialQuery("point",
     "lat", "long", cts.box(10.1, 10.2, 20.1, 20.2));
cts.jsonPropertyPairGeospatialQueryRegion(query);
  
=&gt; [10.1, 10.2, 20.1, 20.2]
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-pair-geospatial-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-pair-geospatial-query("point",
     "lat", "long", cts:box(10.1, 10.2, 20.1, 20.2))
return cts:json-property-pair-geospatial-query-options($query)
  
=&gt; coordinate-system=wgs84
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyPairGeospatialQuery("point",
     "lat", "long", cts.box(10.1, 10.2, 20.1, 20.2));
cts.jsonPropertyPairGeospatialQueryOptions(query);
  
=&gt; coordinate-system=wgs84
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="json-property-pair-geospatial-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:json-property-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:json-property-pair-geospatial-query("point",
     "lat", "long", cts:box(10.1, 10.2, 20.1, 20.2))
return cts:json-property-pair-geospatial-query-weight($query)
  
=&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.jsonPropertyPairGeospatialQuery("point",
     "lat", "long", cts.box(10.1, 10.2, 20.1, 20.2));
cts.jsonPropertyPairGeospatialQueryWeight(query);
  
=&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-pair-geospatial-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching elements by name which has
  specific attributes representing latitude and longitude values for
  a point contained within the given geographic box, circle, or polygon,
  or equal to the given point. Points that lie
  between the southern boundary and the northern boundary of a box,
  travelling northwards,
  and between the western boundary and the eastern boundary of the box,
  travelling eastwards, will match.
  Points contained within the given radius of the center point of a circle will
  match, using the curved distance on the surface of the Earth.
  Points contained within the given polygon will match, using great circle arcs
  over a spherical model of the Earth as edges.  An error may result
  if the polygon is malformed in some way.
  Points equal to the a given point will match, taking into account the fact
  that longitudes converge at the poles.
  Using the geospatial query constructors requires a valid geospatial
  license key; without a valid license key, searches that include
  geospatial queries will throw an exception.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*">
    One or more parent element QNames to match.
    When multiple QNames are specified,
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="latitude-attribute-names" type="xs:QName*">
    One or more latitude attribute QNames to match.
    When multiple QNames are specified, the query matches
    if any QName matches; however, only the first matching latitude
    attribute in any point instance will be checked.
  </apidoc:param>
      <apidoc:param name="longitude-attribute-names" type="xs:QName*">
    One or more longitude attribute QNames to match.
    When multiple QNames are specified, the query matches
    if any QName matches; however, only the first matching longitude
    attribute in any point instance will be checked.
  </apidoc:param>
      <apidoc:param name="regions" type="cts:region*">
    One or more geographic boxes, circles, polygons, or points. Where
    multiple regions
    are specified, the query matches if any region matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are counted
        as matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are not
	counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $regions parameter are
        considered synonyms for scoring purposes.  The result is that
        occurances of more than one of the synonyms are scored as if
        there are more occurance of the same term (as opposed to
        having a separate term that contributes to score). </dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-attribute-pair-geospatial-query</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">The point value is expressed as the numerical values in the
textual content of the named attributes.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">The point values and the boundary specifications are given in degrees
relative to the WGS84 coordinate system.  Southern latitudes and Western
longitudes take negative values.  Longitudes will be wrapped to the range
(-180,+180) and latitudes will be clipped to the range (-90,+90).
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If the northern boundary of a box is south of the southern boundary,
no points will
match. However, longitudes wrap around the globe, so that if the western
boundary is east of the eastern boundary (that is, if the value of 'w' is
greater than the value of 'e'), then the box crosses the anti-meridian.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">Special handling occurs at the poles, as all longitudes exist at latitudes
+90 and -90.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope factor
  will provide useful results. Using a slope factor greater than 1 gives 
  distinct scores over a smaller range of values, and produces generally 
  higher scores.  Using a slope factor less than 1 gives distinct scores 
  over a wider range of values, and produces generally lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root&gt;
  &lt;item&gt;&lt;point lat="10.5" long="30.0"/&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point lat="15.35" long="35.34"/&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point lat="5.11" long="40.55"/&gt;&lt;/item&gt;
&lt;/root&gt; );

cts:search(doc("/points.xml")//item,
  cts:element-attribute-pair-geospatial-query(xs:QName("point"),
    xs:QName("lat"), xs:QName("long"), cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
  &lt;item&gt;&lt;point lat="15.35" long="35.34"/&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-attribute-pair-geospatial-query(xs:QName("point"),
    xs:QName("lat"), xs:QName("long"), cts:box(10.0, 40.0, 20.0, 35.0)))
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;point lat="10.5" long="30.0"/&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-attribute-pair-geospatial-query(xs:QName("point"),
    xs:QName("lat"), xs:QName("long"), cts:box(20.0, 35.0, 10.0, 40.0)))
(:
  throws an error (latitudes do not wrap)
:)
;
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// create documents with test data 
declareUpdate();
xdmp.documentInsert("/point01.xml", xdmp.unquote(
 ' &lt;item&gt;&lt;point lat="10.5" long="30.0"/&gt;&lt;/item&gt;' )),
		
xdmp.documentInsert("/point02.xml", xdmp.unquote(
 '  &lt;item&gt;&lt;point lat="15.35" long="35.34"/&gt;&lt;/item&gt;' )),

xdmp.documentInsert("/point03.xml", xdmp.unquote(
 '  &lt;item&gt;&lt;point lat="5.11" long="40.55"/&gt;&lt;/item&gt;' ));

******
// Now the following search:

cts.search(
  cts.elementAttributePairGeospatialQuery(xs.QName("point"),
    xs.QName("lat"), xs.QName("long"), cts.box(10.0, 35.0, 20.0, 40.0)));

=&gt; returns the document inserted above:
   &lt;item&gt;&lt;point lat="15.35" long="35.34"/&gt;&lt;/item&gt;

cts.search(
  cts.elementAttributePairGeospatialQuery(xs.QName("point"),
    xs.QName("lat"), xs.QName("long"), cts.box(10.0, 40.0, 20.0, 35.0)));

=&gt; returns the document inserted above (wrapping around the Earth):
   &lt;item&gt;&lt;point lat="10.5" long="30.0"/&gt;&lt;/item&gt;

******
// And the following search:

cts.search(
  cts.elementAttributePairGeospatialQuery(xs.QName("point"),
    xs.QName("lat"), xs.QName("long"), cts.box(20.0, 35.0, 10.0, 40.0)));

=&gt; throws an XDMP-BADBOX error (because latitudes do not wrap)
</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-pair-geospatial-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-attribute-pair-geospatial-query-element-name($query)
  
=&gt; "point" (as an xs:QName)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementAttributePairGeospatialQuery(xs.QName("point"),
     xs.QName("lat"), xs.QName("long"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementAttributePairGeospatialQueryElementName(query);
  
=&gt; "point" (as an xs.QName)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-pair-geospatial-query-latitude-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-attribute-pair-geospatial-query-latitude-name($query)
  
=&gt; "lat" (as an xs:QName)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementAttributePairGeospatialQuery(xs.QName("point"),
     xs.QName("lat"), xs.QName("long"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementAttributePairGeospatialQueryLatitudeName(query);
  
=&gt; "lat" (as an xs.QName)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-pair-geospatial-query-longitude-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-attribute-pair-geospatial-query-longitude-name($query)
  
=&gt; "long" (as an xs:QName)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementAttributePairGeospatialQuery(xs.QName("point"),
     xs.QName("lat"), xs.QName("long"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementAttributePairGeospatialQueryLongitudeName(query);
  
=&gt; "long" (as an xs.QName)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-pair-geospatial-query-region" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the geographical regions with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:region*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-attribute-pair-geospatial-query-region($query)
  
=&gt; cts:box("[10.1, 10.2, 20.1, 20.2]")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementAttributePairGeospatialQuery(xs.QName("point"),
     xs.QName("lat"), xs.QName("long"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementAttributePairGeospatialQueryRegion(query);
  
=&gt; [10.1, 10.2, 20.1, 20.2]
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-pair-geospatial-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-attribute-pair-geospatial-query-options($query)
  
=&gt; coordinate-system=wgs84
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementAttributePairGeospatialQuery(xs.QName("point"),
     xs.QName("lat"), xs.QName("long"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementAttributePairGeospatialQueryOptions(query);
  
=&gt; coordinate-system=wgs84
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-pair-geospatial-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-pair-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-attribute-pair-geospatial-query-weight($query)
  
=&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.elementAttributePairGeospatialQuery(xs.QName("point"),
     xs.QName("lat"), xs.QName("long"), cts.box(10.1, 10.2, 20.1, 20.2));
cts.elementAttributePairGeospatialQueryWeight(query);
  
=&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="path-geospatial-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching path expressions whose content
  represents a point contained within the given geographic box, circle, or
  polygon, or equal to the given point. Points that lie
  between the southern boundary and the northern boundary of a box,
  travelling northwards,
  and between the western boundary and the eastern boundary of the box,
  travelling eastwards, will match.
  Points contained within the given radius of the center point of a circle will
  match, using the curved distance on the surface of the Earth.
  Points contained within the given polygon will match, using great circle arcs
  over a spherical model of the Earth as edges.  An error may result
  if the polygon is malformed in some way.
  Points equal to the a given point will match, taking into account the fact
  that longitudes converge at the poles.
  Using the geospatial query constructors requires a valid geospatial
  license key; without a valid license key, searches that include
  geospatial queries will throw an exception.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="path-expression" type="xs:string*">
    One or more path expressions to match.
    When multiple path expressions are specified,
    the query matches if any path expression matches.
  </apidoc:param>
      <apidoc:param name="regions" type="cts:region*">
    One or more geographic boxes, circles, polygons, or points. Where multiple
    regions are specified, the query matches if any region matches.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are counted
        as matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are not
	counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as
	matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"type=long-lat-point"</dt>
        <dd>Specifies the format for the point in the data as longitude first,
        latitude second.</dd>
        <dt>"type=point"</dt>
        <dd>Specifies the format for the point in the data as latitude first,
        longitude second.  This is the default format.</dd>
        <dt>"score-function=<em>function</em>"</dt>
        <dd>Use the selected scoring function. The score function may be:
          <dl>
          <dt>linear</dt><dd>Use a linear function of the difference between the
          specified query value and the matching value in the index to calculate
          a score for this range query.</dd>
          <dt>reciprocal</dt><dd>Use a reciprocal function of the difference
          between the specified query value and the matching value in the
          index to calculate a score for this range query.</dd>
          <dt>zero</dt><dd>This range query does not contribute to the
          score. This is the default.</dd>
          </dl>
        </dd>
        <dt>"slope-factor=<em>number</em>"</dt>
        <dd>Apply the given number as a scaling factor to the slope of the
        scoring function. The default is 1.0.</dd>
        <dt>"synonym"</dt>
        <dd>Specifies that all of the terms in the $regions parameter are
        considered synonyms for scoring purposes.  The result is that
        occurances of more than one of the synonyms are scored as if
        there are more occurance of the same term (as opposed to
        having a separate term that contributes to score). </dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:path-geospatial-query</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">The point value is expressed in the content of an element that matches given
 path expression as a pair of numbers, separated by whitespace and punctuation
 (excluding decimal points and sign characters).
</p>
<p xmlns="http://www.w3.org/1999/xhtml">Point values and boundary specifications of
boxes are given in degrees
relative to the WGS84 coordinate system.  Southern latitudes and Western
longitudes take negative values.  Longitudes will be wrapped to the range
(-180,+180) and latitudes will be clipped to the range (-90,+90).
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If the northern boundary of a box is south of the southern boundary, no
points will match. However, longitudes wrap around the globe, so that if
the western boundary is east of the eastern boundary,
then the box crosses the anti-meridian.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">Special handling occurs at the poles, as all longitudes exist at latitudes
+90 and -90.
</p>
<p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" nor "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope factor
  will provide useful results. Using a slope factor greater than 1 gives 
  distinct scores over a smaller range of values, and produces generally 
  higher scores.  Using a slope factor less than 1 gives distinct scores 
  over a wider range of values, and produces generally lower scores.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">"score-function=linear" means that values that are further away from
  the bounds will score higher. "score-function=reciprocal" means that values
  that are closer to the bounds will score higher. The functions are scaled
  appropriately for different types, so that in general the default slope factor
  will provide useful results. Using a slope factor greater than 1 gives distinct
  scores over a smaller range of values, and produces generally higher scores.
  Using a slope factor less than 1 gives distinct scores over a wider range of
  values, and produces generally lower scores.
  </p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root&gt;
  &lt;item&gt;&lt;point&gt;10.5, 30.0&lt;/point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point&gt;15.35, 35.34&lt;/point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point&gt;5.11, 40.55&lt;/point&gt;&lt;/item&gt;
&lt;/root&gt; );

cts:search(doc("/points.xml")//item,
  cts:path-geospatial-query("/root/item/point", 
	  cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
  &lt;item&gt;&lt;point&gt;15.35, 35.34&lt;/point&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:path-geospatial-query("//item/point", cts:box(10.0, 40.0, 20.0, 35.0)))
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;point&gt;10.5, 30.0&lt;/point&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:path-geospatial-query("//point", cts:box(20.0, 35.0, 10.0, 40.0)))
(:
  throws an error (latitudes do not wrap)
:)
;
</pre>
</apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// create documents with test data 
declareUpdate();
xdmp.documentInsert("/point1.xml", xdmp.unquote(
 ' &lt;item&gt;&lt;point&gt;10.5, 30.0&lt;/point&gt;&lt;/item&gt;' )),
		
xdmp.documentInsert("/point2.xml", xdmp.unquote(
 '  &lt;item&gt;&lt;point&gt;15.35, 35.34&lt;/point&gt;&lt;/item&gt;' )),

xdmp.documentInsert("/point3.xml", xdmp.unquote(
 '  &lt;item&gt;&lt;point&gt;5.11, 40.55&lt;/point&gt;&lt;/item&gt;' ));

******
// Now the following search:

cts.search(
  cts.pathGeospatialQuery("/item/point", cts.box(10.0, 35.0, 20.0, 40.0)));

// returns the /point2.xml document created above:
   &lt;item&gt;&lt;point&gt;15.35, 35.34&lt;/point&gt;&lt;/item&gt;

******
// And the following search:

cts.search(
  cts.pathGeospatialQuery("//item/point", cts.box(10.0, 40.0, 20.0, 35.0)));

=&gt; returns the /point1.xml document created above (wrapping around the Earth):
   &lt;item&gt;&lt;point&gt;10.5, 30.0&lt;/point&gt;&lt;/item&gt;

******
// And the following search:

cts.search(
  cts.pathGeospatialQuery("//point", cts.box(20.0, 35.0, 10.0, 40.0)));

=&gt; throws an XDMP-BADBOX error (because latitudes do not wrap)
</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="path-geospatial-query-region" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the geographical regions
  with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:path-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:region*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:path-geospatial-query("//point",
       cts:box(10.1, 10.2, 20.1, 20.2))
return cts:path-geospatial-query-region($query)
  
=&gt; cts:box("[10.1, 10.2, 20.1, 20.2]")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.pathGeospatialQuery("//point",
       cts.box(10.1, 10.2, 20.1, 20.2))
cts.pathGeospatialQueryRegion(query);
  
=&gt; [10.1, 10.2, 20.1, 20.2]
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="path-geospatial-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:path-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:path-geospatial-query("//point",
       cts:box(10.1, 10.2, 20.1, 20.2))
return cts:path-geospatial-query-options($query)
  
=&gt; coordinate-system=wgs84
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.pathGeospatialQuery("//point",
       cts.box(10.1, 10.2, 20.1, 20.2))
cts.pathGeospatialQueryOptions(query);
  
=&gt; coordinate-system=wgs84
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="path-geospatial-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:path-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:path-geospatial-query("//point",
       cts:box(10.1, 10.2, 20.1, 20.2))
return cts:path-geospatial-query-weight($query)
  
=&gt; 1
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.pathGeospatialQuery("//point",
       cts.box(10.1, 10.2, 20.1, 20.2))
cts.pathGeospatialQueryWeight(query);
  
=&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="path-geospatial-query-path-expression" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors">
    <apidoc:summary>
  Returns the path expressions used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:path-geospatial-query">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:path-geospatial-query("//point",
       cts:box(10.1, 10.2, 20.1, 20.2))
return cts:path-geospatial-query-path-expression($query)
  
=&gt; "//point"
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var query = cts.pathGeospatialQuery("//point",
       cts.box(10.1, 10.2, 20.1, 20.2))
cts.pathGeospatialQueryPathExpression(query);
  
=&gt; "//point"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-geospatial-boxes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  <p xmlns="http://www.w3.org/1999/xhtml">Returns boxes derived from the specified element point lexicon(s).
  Element point lexicons are implemented using geospatial indexes; consequently
  this function requires an element geospatial index for each element
  specified in the function.  If there is not a geospatial index configured for
  each of the specified elements, an exception is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">The points are divided into box-shaped buckets. The $latitude-bounds and
  $longitude-bounds parameters specify the number and the size of each
  box-shaped bucket. All included points are bucketed, even those outside
  the bounds.  An empty sequence for both $latitude-bounds and
  $longitude-bounds specifies one bucket, a single value for both specifies
  four buckets, two values for both specify nine buckets, and so on.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, a <code>cts:box</code> value is returned.
  By default, the <code>cts:box</code> value is the minimum bounding box
  of all the points in the bucket.  If the "gridded" option is specified,
  then if a bucket is bounded on a side, its corresponding
  <code>cts:box</code> side is the bound.
  Empty buckets return nothing unless the "empties" option is specified.</p>
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="latitude-bounds" type="xs:double*" optional="true">
    A sequence of latitude bounds.
    The values must be in strictly ascending order, otherwise an exception
    is thrown.
  </apidoc:param>
      <apidoc:param name="longitude-bounds" type="xs:double*" optional="true">
    A sequence of longitude bounds.
    The values must be in strictly ascending order, otherwise an exception
    is thrown.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Boxes should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Boxes should be returned in descending order.</dd>
        <dt>"gridded"</dt>
        <dd>For each side that a bucket is bounded, return the corresponding
        bound as the edge of the box, instead of the extremum from the
        points in the bucket.</dd>
        <dt>"empties"</dt>
        <dd>Include fully-bounded ranges whose frequency is 0.  Only
        empty ranges that have
        both their upper and lower bounds specified in the $bounds
        options are returned;
        any empty ranges that are less than the first bound or greater than the
        last bound are not returned.  For example, if you specify 4 bounds
        and there are no results for any of the bounds, 3 elements are
        returned (not 5 elements).</dd>
        <dt>"any"</dt>
        <dd>Points from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Points from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Points from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Points from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Boxes should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Boxes should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included point.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included point.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>Use the lexicon with the coordinate system specified by
        <em>name</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> boxes.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Points from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only boxes for buckets with at least one point from
        the first <em>N</em> fragments after skip selected by the
        <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only points from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"type=long-lat-point"</dt>
        <dd>Specifies the format for the point in the data as longitude first,
        latitude second.</dd>
        <dt>"type=point"</dt>
        <dd>Specifies the format for the point in the data as latitude first,
        longitude second.  This is the default format.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a cts:box* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include points in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included points.
    The points do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:box*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "empties" 
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all boxes with included points may be returned. If a <code>$query</code>
  parameter is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then points from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: 
   Create a 15 degree latitude by 30 degree longitude grid over the
   Eastern part of the Northern hemisphere, figure out how many points in
   the element "point" are in each grid section, and return a box for each
   grid section, whether it has points in it or not. The box will have the 
   actual min/max latitudes and longitudes of points in that grid section as 
   its bounds. Order the boxes in increasing order of latitude and longitude,
   and return the frequency of points in the box and the box itself.
 :)
for $box in 
  cts:element-geospatial-boxes(xs:QName("point"),
    (15, 30, 45, 60, 75), (0, 30, 60, 90, 120),
    ("ascending", "empties"))
return (cts:frequency($box), $box)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   Create a 15 degree latitude by 30 degree longitude grid over the
//   Eastern part of the Northern hemisphere, figure out how many points in
//   the element "point" are in each grid section, and return a box for each
//   grid section, whether it has points in it or not. The box will have the 
//   actual min/max latitudes and longitudes of points in that grid section as 
//   its bounds. Order the boxes in increasing order of latitude and longitude,
//   and return the frequency of points in the box and the box itself.

var obj = new Object();
for (var box of 
  cts.elementGeospatialBoxes(xs.QName("point"),
    [15, 30, 45, 60, 75], [0, 30, 60, 90, 120],
    ["ascending", "empties"])) {
  obj[box] = cts.frequency(box);
};
obj;

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-child-geospatial-boxes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  <p xmlns="http://www.w3.org/1999/xhtml">Returns boxes derived from the specified element point lexicon(s).
  Element point lexicons are implemented using geospatial indexes; consequently
  this function requires an element child geospatial index for each element
  specified in the function.  If there is not a geospatial index configured for
  each of the specified element/child combinations, an exception is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">The points are divided into box-shaped buckets. The $latitude-bounds and
  $longitude-bounds parameters specify the number and the size of each
  box-shaped bucket. All included points are bucketed, even those outside
  the bounds.  An empty sequence for both $latitude-bounds and
  $longitude-bounds specifies one bucket, a single value for both specifies
  four buckets, two values for both specify nine buckets, and so on.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, a <code>cts:box</code> value is returned.
  By default, the <code>cts:box</code> value is the minimum bounding box
  of all the points in the bucket.  If the "gridded" option is specified,
  then if a bucket is bounded on a side, its corresponding
  <code>cts:box</code> side is the bound.
  Empty buckets return nothing unless the "empties" option is specified.</p>
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="parent-element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="child-element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="latitude-bounds" type="xs:double*" optional="true">
    A sequence of latitude bounds.
    The values must be in strictly ascending order, otherwise an exception
    is thrown.
  </apidoc:param>
      <apidoc:param name="longitude-bounds" type="xs:double*" optional="true">
    A sequence of longitude bounds.
    The values must be in strictly ascending order, otherwise an exception
    is thrown.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Boxes should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Boxes should be returned in descending order.</dd>
        <dt>"gridded"</dt>
        <dd>For each side that a bucket is bounded, return the corresponding
        bound as the edge of the box, instead of the extremum from the
        points in the bucket.</dd>
        <dt>"empties"</dt>
        <dd>Include fully-bounded ranges whose frequency is 0.   Only
        empty ranges that have
        both their upper and lower bounds specified in the $bounds
        options are returned;
        any empty ranges that are less than the first bound or greater than the
        last bound are not returned.  For example, if you specify 4 bounds
        and there are no results for any of the bounds, 3 elements are
        returned (not 5 elements).</dd>
        <dt>"any"</dt>
        <dd>Points from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Points from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Points from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Points from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Boxes should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Boxes should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included point.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included point.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>Use the lexicon with the coordinate system specified by
        <em>name</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> boxes.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Points from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only boxes for buckets with at least one point from
        the first <em>N</em> fragments after skip selected by the
        <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only points from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"type=long-lat-point"</dt>
        <dd>Specifies the format for the point in the data as longitude first,
        latitude second.</dd>
        <dt>"type=point"</dt>
        <dd>Specifies the format for the point in the data as latitude first,
        longitude second.  This is the default format.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a cts:box* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include points in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included points.
    The points do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:box*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "empties" 
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all boxes with included points may be returned. If a <code>$query</code>
  parameter is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then points from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: 
   Create a 15 degree latitude by 30 degree longitude grid over the
   Eastern part of the Northern hemisphere, figure out how many points in
   the element "point" as a child of the element "location" are in each grid
   section, and return a box for each grid section, whether it has points in 
   it or not. The box will have the actual min/max latitudes and longitudes
   of points in that grid section as its bounds. Order the boxes in increasing
   order of latitude and longitude, and return the frequency of points in
   the box and the box itself.
 :)
for $box in 
  cts:element-child-geospatial-boxes(xs:QName("location"), xs:QName("point")
    (15, 30, 45, 60, 75), (0, 30, 60, 90, 120),
    ("ascending", "empties"))
return (cts:frequency($box), $box)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   Create a 15 degree latitude by 30 degree longitude grid over the
//   Eastern part of the Northern hemisphere, figure out how many points in
//   the element "point" as a child of the element "location" are in each grid
//   section, and return a box for each grid section, whether it has points in 
//   it or not. The box will have the actual min/max latitudes and longitudes
//   of points in that grid section as its bounds. Order the boxes in increasing
//   order of latitude and longitude, and return the frequency of points in
//   the box and the box itself.
 
var obj = new Object();
for (var box of 
  cts.elementChildGeospatialBoxes(xs.QName("location"), xs.QName("point"),
    [15, 30, 45, 60, 75], [0, 30, 60, 90, 120],
    ["ascending", "empties"])) {
  obj[box] = cts.frequency(box);
};
obj;

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-pair-geospatial-boxes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  <p xmlns="http://www.w3.org/1999/xhtml">Returns boxes derived from the specified element point lexicon(s).
  Element point lexicons are implemented using geospatial indexes; consequently
  this function requires a geospatial element pair index for each
  parent and pair of child elements
  specified in the function.  If there is not a geospatial index configured for
  each of the specified combinations, an exception is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">The points are divided into box-shaped buckets. The $latitude-bounds and
  $longitude-bounds parameters specify the number and the size of each
  box-shaped bucket. All included points are bucketed, even those outside
  the bounds.  An empty sequence for both $latitude-bounds and
  $longitude-bounds specifies one bucket, a single value for both specifies
  four buckets, two values for both specify nine buckets, and so on.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, a <code>cts:box</code> value is returned.
  By default, the <code>cts:box</code> value is the minimum bounding box
  of all the points in the bucket.  If the "gridded" option is specified,
  then if a bucket is bounded on a side, its corresponding
  <code>cts:box</code> side is the bound.
  Empty buckets return nothing unless the "empties" option is specified.</p>
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="parent-element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="latitude-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="longitude-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="latitude-bounds" type="xs:double*" optional="true">
    A sequence of latitude bounds.
    The values must be in strictly ascending order, otherwise an exception
    is thrown.
  </apidoc:param>
      <apidoc:param name="longitude-bounds" type="xs:double*" optional="true">
    A sequence of longitude bounds.
    The values must be in strictly ascending order, otherwise an exception
    is thrown.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Boxes should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Boxes should be returned in descending order.</dd>
        <dt>"gridded"</dt>
        <dd>For each side that a bucket is bounded, return the corresponding
        bound as the edge of the box, instead of the extremum from the
        points in the bucket.</dd>
        <dt>"empties"</dt>
        <dd>Include fully-bounded ranges whose frequency is 0. Only
        empty ranges that have
        both their upper and lower bounds specified in the $bounds
        options are returned;
        any empty ranges that are less than the first bound or greater than the
        last bound are not returned.  For example, if you specify 4 bounds
        and there are no results for any of the bounds, 3 elements are
        returned (not 5 elements).</dd>
        <dt>"any"</dt>
        <dd>Points from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Points from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Points from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Points from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Boxes should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Boxes should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included point.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included point.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>Use the lexicon with the coordinate system specified by
        <em>name</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> boxes.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Points from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only boxes for buckets with at least one point from
        the first <em>N</em> fragments after skip selected by the
        <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only points from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a cts:box* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include points in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included points.
    The points do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:box*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "empties" 
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all boxes with included points may be returned. If a <code>$query</code>
  parameter is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then points from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: 
   Create a 15 degree latitude by 30 degree longitude grid over the
   Eastern part of the Northern hemisphere, figure out how many points are 
   in each grid section, and return a box for each grid section, whether it
   has points in it or not. The box will have the actual min/max latitudes 
   and longitudes of points in that grid section as its bounds. Order the boxes
   in increasing order of latitude and longitude, and return the frequency
   of points in the box and the box itself.
   
   The points will be those in the element "point" where the latitude value is
   in the child "lat" and the longitude value is in the child "long".
 :)
for $box in 
  cts:element-pair-geospatial-boxes(
    xs:QName("point"), xs:QName("lat"), xs:QName("long"),
    (15, 30, 45, 60, 75), (0, 30, 60, 90, 120),
    ("ascending", "empties"))
return (cts:frequency($box), $box)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   Create a 15 degree latitude by 30 degree longitude grid over the
//   Eastern part of the Northern hemisphere, figure out how many points are 
//   in each grid section, and return a box for each grid section, whether it
//   has points in it or not. The box will have the actual min/max latitudes 
//   and longitudes of points in that grid section as its bounds. Order the 
//   boxes in increasing order of latitude and longitude, and return the 
//   frequency of points in the box and the box itself.
   
//   The points will be those in the element "point" where the latitude value is
//   in the child "lat" and the longitude value is in the child "long".
 
var obj = new Object();
for (var box of cts.elementPairGeospatialBoxes(xs,QName("point"), 
			xs.QName("lat"), xs.QName("long"),
    [15, 30, 45, 60, 75], [0, 30, 60, 90, 120],
    ["ascending", "empties"])) {
  obj[box] = cts.frequency(box);
};
obj;

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-pair-geospatial-boxes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  <p xmlns="http://www.w3.org/1999/xhtml">Returns boxes derived from the specified element point lexicon(s).
  Element point lexicons are implemented using geospatial indexes; consequently
  this function requires a geospatial element attribute pair index for each
  prarent element and attribute pair
  specified in the function.  If there is not a geospatial index configured for
  each of the specified combinations, an exception is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">The points are divided into box-shaped buckets. The $latitude-bounds and
  $longitude-bounds parameters specify the number and the size of each
  box-shaped bucket. All included points are bucketed, even those outside
  the bounds.  An empty sequence for both $latitude-bounds and
  $longitude-bounds specifies one bucket, a single value for both specifies
  four buckets, two values for both specify nine buckets, and so on.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, a <code>cts:box</code> value is returned.
  By default, the <code>cts:box</code> value is the minimum bounding box
  of all the points in the bucket.  If the "gridded" option is specified,
  then if a bucket is bounded on a side, its corresponding
  <code>cts:box</code> side is the bound.
  Empty buckets return nothing unless the "empties" option is specified.</p>
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="parent-element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="latitude-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="longitude-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="latitude-bounds" type="xs:double*" optional="true">
    A sequence of latitude bounds.
    The values must be in strictly ascending order, otherwise an exception
    is thrown.
  </apidoc:param>
      <apidoc:param name="longitude-bounds" type="xs:double*" optional="true">
    A sequence of longitude bounds.
    The values must be in strictly ascending order, otherwise an exception
    is thrown.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Boxes should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Boxes should be returned in descending order.</dd>
        <dt>"gridded"</dt>
        <dd>For each side that a bucket is bounded, return the corresponding
        bound as the edge of the box, instead of the extremum from the
        points in the bucket.</dd>
        <dt>"empties"</dt>
        <dd>Include fully-bounded ranges whose frequency is 0.  Only
        empty ranges that have
        both their upper and lower bounds specified in the $bounds
        options are returned;
        any empty ranges that are less than the first bound or greater than the
        last bound are not returned.  For example, if you specify 4 bounds
        and there are no results for any of the bounds, 3 elements are
        returned (not 5 elements).</dd>
        <dt>"any"</dt>
        <dd>Points from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Points from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Points from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Points from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Boxes should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Boxes should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included point.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included point.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>Use the lexicon with the coordinate system specified by
        <em>name</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> boxes.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Points from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only boxes for buckets with at least one point from
        the first <em>N</em> fragments after skip selected by the
        <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only points from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a cts:box* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include points in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included points.
    The points do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:box*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "empties" 
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all boxes with included points may be returned. If a <code>$query</code>
  parameter is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then points from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: 
   Create a 15 degree latitude by 30 degree longitude grid over the
   Eastern part of the Northern hemisphere, figure out how many points are 
   in each grid section, and return a box for each grid section, whether it
   has points in it or not. The box will have the actual min/max latitudes 
   and longitudes of points in that grid section as its bounds. Order the boxes
   in increasing order of latitude and longitude, and return the frequency
   of points in the box and the box itself.
   
   The points will be those in the element "point" where the latitude value is
   in the attribute "lat" and the longitude value is in the attribute "long".
 :)
for $box in 
  cts:element-attribute-pair-geospatial-boxes(
    xs:QName("point"), xs:QName("lat"), xs:QName("long"),
    (15, 30, 45, 60, 75), (0, 30, 60, 90, 120),
    ("ascending", "empties"))
return (cts:frequency($box), $box)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   Create a 15 degree latitude by 30 degree longitude grid over the
//   Eastern part of the Northern hemisphere, figure out how many points are 
//   in each grid section, and return a box for each grid section, whether it
//   has points in it or not. The box will have the actual min/max latitudes 
//   and longitudes of points in that grid section as its bounds. Order the 
//   boxes in increasing order of latitude and longitude, and return the 
//   frequency of points in the box and the box itself.
   
//   The points will be those in the element "point" where the latitude value is
//   in the attribute "lat" and the longitude value is in the attribute "long".

var obj = new Object();
for (var box of cts.elementAttributePairGeospatialBoxes(
    xs.QName("point"), xs.QName("lat"), xs.QName("long"),
    [15, 30, 45, 60, 75], [0, 30, 60, 90, 120],
    ["ascending", "empties")) {
  obj[box] = cts.frequency(box);
};
obj;

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="geospatial-boxes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  <p xmlns="http://www.w3.org/1999/xhtml">Returns boxes derived from the specified point lexicon(s).
  Point lexicons are implemented using geospatial indexes; consequently
  this function requires a geospatial index for each $geo-indexes
  specified in the function. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">The points are divided into box-shaped buckets. The $latitude-bounds and
  $longitude-bounds parameters specify the number and the size of each
  box-shaped bucket. All included points are bucketed, even those outside
  the bounds.  An empty sequence for both $latitude-bounds and
  $longitude-bounds specifies one bucket, a single value for both specifies
  four buckets, two values for both specify nine buckets, and so on.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, a <code>cts:box</code> value is returned.
  By default, the <code>cts:box</code> value is the minimum bounding box
  of all the points in the bucket.  If the "gridded" option is specified,
  then if a bucket is bounded on a side, its corresponding
  <code>cts:box</code> side is the bound.
  Empty buckets return nothing unless the "empties" option is specified.</p>
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="geo-indexes" type="cts:reference*">
    A sequence of references to geospatial indexes.
  </apidoc:param>
      <apidoc:param name="latitude-bounds" type="xs:double*" optional="true">
    A sequence of latitude bounds.
    The values must be in strictly ascending order, otherwise an exception
    is thrown.
  </apidoc:param>
      <apidoc:param name="longitude-bounds" type="xs:double*" optional="true">
    A sequence of longitude bounds.
    The values must be in strictly ascending order, otherwise an exception
    is thrown.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Boxes should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Boxes should be returned in descending order.</dd>
        <dt>"gridded"</dt>
        <dd>For each side that a bucket is bounded, return the corresponding
        bound as the edge of the box, instead of the extremum from the
        points in the bucket.</dd>
        <dt>"empties"</dt>
        <dd>Include fully-bounded ranges whose frequency is 0.  Only
        empty ranges that have
        both their upper and lower bounds specified in the $bounds
        options are returned;
        any empty ranges that are less than the first bound or greater than the
        last bound are not returned.  For example, if you specify 4 bounds
        and there are no results for any of the bounds, 3 elements are
        returned (not 5 elements).</dd>
        <dt>"any"</dt>
        <dd>Points from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Points from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Points from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Points from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Boxes should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Boxes should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included point.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included point.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>Use the lexicon with the coordinate system specified by
        <em>name</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> boxes.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Points from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only boxes for buckets with at least one point from
        the first <em>N</em> fragments after skip selected by the
        <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only points from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"type=long-lat-point"</dt>
        <dd>Specifies the format for the point in the data as longitude first,
        latitude second.</dd>
        <dt>"type=point"</dt>
        <dd>Specifies the format for the point in the data as latitude first,
        longitude second.  This is the default format.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a cts:box* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include points in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included points.
    The points do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:box*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "empties" 
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all boxes with included points may be returned. If a <code>$query</code>
  parameter is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then points from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: 
   Create a 15 degree latitude by 30 degree longitude grid over the
   Eastern part of the Northern hemisphere, figure out how many points in
   the element "point" are in each grid section, and return a box for each
   grid section, whether it has points in it or not. The box will have the 
   actual min/max latitudes and longitudes of points in that grid section as 
   its bounds. Order the boxes in increasing order of latitude and longitude,
   and return the frequency of points in the box and the box itself.
 :)
for $box in 
  cts:geospatial-boxes(cts:element-reference(xs:QName("point")),
    (15, 30, 45, 60, 75), (0, 30, 60, 90, 120),
    ("ascending", "empties"))
return (cts:frequency($box), $box)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   Create a 15 degree latitude by 30 degree longitude grid over the
//   Eastern part of the Northern hemisphere, figure out how many points in
//   the element "point" are in each grid section, and return a box for each
//   grid section, whether it has points in it or not. The box will have the 
//   actual min/max latitudes and longitudes of points in that grid section as 
//   its bounds. Order the boxes in increasing order of latitude and longitude,
//   and return the frequency of points in the box and the box itself.
 
var obj = new Object();
for (var box of cts.geospatialBoxes(cts.elementReference(xs.QName("point")),
    [15, 30, 45, 60, 75], [0, 30, 60, 90, 120],
    ["ascending", "empties"])) {
  obj[box] = cts.frequency(box);
};
obj;
	
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-geospatial-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Returns values from the specified element geospatial value lexicon(s).
  Geospatial value lexicons are implemented using geospatial indexes;
  consequently this function requires an element geospatial index for each
  element specified
  in the function.  If there is not a geospatial index configured for each
  of the specified elements, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="start" type="cts:point?" optional="true">
    A starting value.
    If the parameter value is not in the lexicon, then the values are
    returned beginning with the next value.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>Use the lexicon with the coordinate system specified by
        <em>name</em>.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"type=long-lat-point"</dt>
        <dd>Specifies the format for the point in the data as longitude first,
        latitude second.</dd>
        <dt>"type=point"</dt>
        <dd>Specifies the format for the point in the data as latitude first,
        longitude second.  This is the default format.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a cts:point* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-geospatial-values(xs:QName("point"),cts:point(0,0))
  =&gt; (cts:point(0,0),cts:point(0,10),cts:point(0,20),...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.elementGeospatialValues(xs.QName("point"), cts.point(0,0));
  =&gt; (cts:point(0,0),cts:point(0,10),cts:point(0,20),...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-child-geospatial-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Returns values from the specified element-child geospatial value lexicon(s).
  Element-child geospatial value lexicons are implemented using geospatial
  indexes;
  consequently this function requires an element-child geospatial index
  of for each of the element/child pairs specified in the function.
  If there is not a range index configured for each of the specified
  element/child pairs, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="child-names" type="xs:QName*">
    One or more child element QNames.
  </apidoc:param>
      <apidoc:param name="start" type="cts:point?" optional="true">
    A starting value.
    If the parameter value is not in the lexicon, then the values are
    returned beginning with the next value.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>Use the lexicon with the coordinate system specified by
        <em>name</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"type=long-lat-point"</dt>
        <dd>Specifies the format for the point in the data as longitude first,
        latitude second.</dd>
        <dt>"type=point"</dt>
        <dd>Specifies the format for the point in the data as latitude first,
        longitude second.  This is the default format.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a cts:point* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or child QNames are specified,
  then all possible element/child QName combinations are used
  to select the matching values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-child-geospatial-values(
     xs:QName("location"), xs:QName("position"), cts:point(0,0) )
  =&gt; (cts:point(0,0),cts:point(0,10),cts:point(0,20),...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.elementChildGeospatialValues(
     xs.QName("location"), xs.QName("position"), cts.point(0,0) );
  =&gt; (cts:point(0,0),cts:point(0,10),cts:point(0,20),...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-pair-geospatial-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Returns values from the specified element-pair geospatial value lexicon(s).
  element-pair geospatial value lexicons are implemented using geospatial
  indexes;
  consequently this function requires an element-pair geospatial index
  of for each of the combinatation specified in the function.
  If there is not a geospatial index configured for each of the specified
  combinations, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="latitude-names" type="xs:QName*">
    One or more latitude element QNames.
  </apidoc:param>
      <apidoc:param name="longitude-names" type="xs:QName*">
    One or more longitude element QNames.
  </apidoc:param>
      <apidoc:param name="start" type="cts:point?" optional="true">
    A starting value.
    If the parameter value is not in the lexicon, then the values are
    returned beginning with the next value.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>Use the lexicon with the coordinate system specified by
        <em>name</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a cts:point* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or child QNames are specified,
  then all possible element/child QName combinations are used
  to select the matching values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-pair-geospatial-values( xs:QName("point"),
     xs:QName("lat"), xs:QName("lon"), cts:point(0,0) )
  =&gt; (cts:point(0,0),cts:point(0,10),cts:point(0,20),...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.elementPairGeospatialValues( xs.QName("point"),
     xs.QName("lat"), xs.QName("lon"), cts.point(0,0) );
  =&gt; (cts:point(0,0),cts:point(0,10),cts:point(0,20),...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-pair-geospatial-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Returns values from the specified element-attribute-pair geospatial value lexicon(s).
  element-attribute-pair geospatial value lexicons are implemented using geospatial
  indexes;
  consequently this function requires an element-attribute-pair geospatial index
  of for each of the combinatation specified in the function.
  If there is not a geospatial index configured for each of the specified
  combinations, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="latitude-names" type="xs:QName*">
    One or more latitude element QNames.
  </apidoc:param>
      <apidoc:param name="longitude-names" type="xs:QName*">
    One or more longitude element QNames.
  </apidoc:param>
      <apidoc:param name="start" type="cts:point?" optional="true">
    A starting value.
    If the parameter value is not in the lexicon, then the values are
    returned beginning with the next value.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>Use the lexicon with the coordinate system specified by
        <em>name</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em> fragments after
        skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a cts:point* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or child QNames are specified,
  then all possible element/child QName combinations are used
  to select the matching values.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-pair-geospatial-values(
     xs:QName("location"), xs:QName("lat"), 
     xs:QName("long"), cts:point(0,0) )
  =&gt; (cts:point(0,0),cts:point(0,10),cts:point(0,20),...)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.elementAttributePairGeospatialValues(
     xs.QName("location"), xs.QName("lat"), 
     xs.QName("long"), cts.point(0,0) );
  =&gt; (cts:point(0,0),cts:point(0,10),cts:point(0,20),...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-geospatial-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
   Returns values from the specified element geospatial value lexicon(s)
   that match the specified wildcard pattern.  Element geospatial value lexicons
   are implemented using geospatial indexes; consequently this function
   requires an element geospatial index for each element specified in the
   function.  If there is not a geospatial index configured for each of the
   specified elements, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:anyAtomicType">
    A pattern to match.  The parameter type must match the lexicon type.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>Use the lexicon with the coordinate system specified by
        <em>name</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"type=long-lat-point"</dt>
        <dd>Specifies the format for the point in the data as longitude first,
        latitude second.</dd>
        <dt>"type=point"</dt>
        <dd>Specifies the format for the point in the data as latitude first,
        longitude second.  This is the default format.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a cts:point* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point*</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-geospatial-value-match(xs:QName("point"),cts:point(10,20))
  =&gt; 10,20
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.elementGeospatialValueMatch(xs.QName("point"), cts.point(10,20));
  =&gt; 10,20
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-child-geospatial-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
   Returns values from the specified element child geospatial value lexicon(s)
   that match the specified wildcard pattern.  Element
   child geospatial value lexicons
   are implemented using geospatial indexes; consequently this function
   requires an element child geospatial index for each element and child
   specified in the
   function.  If there is not a geospatial index configured for each of the
   specified elements/child combinations, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="child-names" type="xs:QName*">
    One or more child element QNames.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:anyAtomicType">
    A pattern to match.  The parameter type must match the lexicon type.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>Use the lexicon with the coordinate system specified by
        <em>name</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"type=long-lat-point"</dt>
        <dd>Specifies the format for the point in the data as longitude first,
        latitude second.</dd>
        <dt>"type=point"</dt>
        <dd>Specifies the format for the point in the data as latitude first,
        longitude second.  This is the default format.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a cts:point* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point*</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-child-geospatial-value-match(
     xs:QName("location"),xs:QName("pos"),cts:point(10,20))
  =&gt; 10,20
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.elementChildGeospatialValueMatch(
     xs.QName("location"), xs.QName("pos"), cts.point(10,20));
  =&gt; 10,20
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-pair-geospatial-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
   Returns values from the specified element pair geospatial value lexicon(s)
   that match the specified wildcard pattern.  Element pair
   geospatial value lexicons
   are implemented using geospatial indexes; consequently this function
   requires an element pair geospatial index for each combination of elements
   specified in the
   function.  If there is not a geospatial index configured for each of the
   specified combinations, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="latitude-names" type="xs:QName*">
    One or more latitude element QNames.
  </apidoc:param>
      <apidoc:param name="longitude-names" type="xs:QName*">
    One or more longitude element QNames.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:anyAtomicType">
    A pattern to match.  The parameter type must match the lexicon type.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>Use the lexicon with the coordinate system specified by
        <em>name</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a cts:point* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point*</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-pair-geospatial-value-match(
     xs:QName("location"),xs:QName("lat"),xs:QName("long"),cts:point(10,20))
  =&gt; 10,20
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.elementPairGeospatialValueMatch(
     xs.QName("location"), xs.QName("lat"),
     xs.QName("long"), cts.point(10,20));
  =&gt; 10,20
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-pair-geospatial-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
   Returns values from the specified element attribute pair geospatial value
   lexicon(s)
   that match the specified wildcard pattern.  Element attribute pair
   geospatial value lexicons
   are implemented using geospatial indexes; consequently this function
   requires an element attribute pair geospatial index for each combination
   of elements and attributes specified in the
   function.  If there is not a geospatial index configured for each of the
   specified combinations, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="latitude-names" type="xs:QName*">
    One or more latitude element QNames.
  </apidoc:param>
      <apidoc:param name="longitude-names" type="xs:QName*">
    One or more longitude element QNames.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:anyAtomicType">
    A pattern to match.  The parameter type must match the lexicon type.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>Use the lexicon with the coordinate system specified by
        <em>name</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Values from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a cts:point* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included values.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point*</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "lazy" if "item-order" is
  specified, and "eager" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then values from all fragments selected by the <code>$query</code> parameter
  are included.  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-pair-geospatial-value-match(
     xs:QName("location"),xs:QName("lat"),xs:QName("long"),cts:point(10,20))
  =&gt; 10,20
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts.elementAttributePairGeospatialValueMatch(
     xs.QName("location"), xs.QName("lat"),
     xs.QName("long"), cts.point(10,20));
  =&gt; 10,20
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-geospatial-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Returns value co-occurrences from the specified element
  value lexicon with the specified geospatial lexicon.
  Value lexicons are implemented using range indexes;
  consequently this function requires a range index for the element
  specified in the function.
  If there is not a range index configured for the specified
  element, then an exception is thrown.
  Geospatial lexicons are implemented using geospatial indexes;
  consequently this function requires a geospatial index for the
  element/attribute combination specified in the function.
  If there is not a geospatial index configured for the specified
  element/attribute combination, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name-1" type="xs:QName">
    An element QName.
  </apidoc:param>
      <apidoc:param name="geo-element-name" type="xs:QName">
    An element QName.
  </apidoc:param>
      <apidoc:param name="child-name-1" type="xs:QName?" optional="true">
    An element or attribute QName or empty sequence.
    The empty sequence specifies an element geospatial lexicon.
  </apidoc:param>
      <apidoc:param name="child-name-2" type="xs:QName?" optional="true">
    An element or attribute QName or empty sequence.
    The empty sequence specifies either an element lexicon or an
    element-child geospatial lexicon.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"geospatial-format=<em>format</em>"</dt>
        <dd>Use the kind of geospatial lexicon specified by <em>format</em>
        (element, element-child, element-pair, or element-attribute-pair).
        If neither of the child QNames is specified, the default is
        "element"; if only the first of the child QNames is specified,
        the default is "element-child:; if both child QNames are specified,
        the default is "element-pair".  If the selection is not compatible
        with the number of geospatial QNames specified, an error is raised.
        </dd>
        <dt>"ascending"</dt>
        <dd>Co-occurrences should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Co-occurrences should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Co-occurrences from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Co-occurrences from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Co-occurrences from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Co-occurrences from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Co-occurrences should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Co-occurrences should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included co-occurrences.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included co-occurrence.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>For the non-geospatial lexicon, use the type specified by
        <em>type</em> (int, unsignedInt, long, unsignedLong, float, double,
        decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"type-2=<em>type</em>"</dt>
        <dd>For the geospatial lexicon, use the type specified by
        <em>type-2</em> (point or long-lat-point)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>For the non-geospatial lexicon, use the collation specified by
        <em>URI</em>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>For the geospatial lexicons, use the coordinate system specified
        by <em>name</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"ordered"</dt>
        <dd>Include co-occurrences only when the value from the first lexicon
        appears before the value from the second lexicon.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"reversed"</dt>
        <dd>Consider the second lexicon as the first and vice versa.</dd>
        <dt>"proximity=<em>N</em>"</dt>
        <dd>Include co-occurrences only when the values appear within
        <em>N</em> words of each other.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> co-occurrences.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Co-occurrences from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a element(cts:co-occurrence)* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include co-occurrences in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included co-occurrences.
    The co-occurrences do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:co-occurrence)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "map" 
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all included co-occurrences may be returned.
  If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then co-occurrences from all fragments selected by the
  <code>$query</code> parameter are included.
  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: 
   Get the co-occurrences of the "person" element with points encoded as
   "point" children of "location" elements. Return the co-occurrences as
   a sequence of XML nodes with frequencies.
:)
declare namespace geoex = "http://example.com/ns/geo"; 
 
cts:element-value-geospatial-co-occurrences( 
     xs:QName("geoex:person"), 
     xs:QName("geoex:location"), 
     xs:QName("geoex:point"), 
     (), 
     ("collation=http://marklogic.com/collation/codepoint"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
 
//   Get the co-occurrences of the "person" element with points encoded as
//   "point" children of "location" elements. Return the co-occurrences as
//   a sequence of XML nodes with frequencies.

cts.elementValueGeospatialCoOccurrences( 
     fn.QName("http://example.com/ns/geo", "person"), 
     fn.QName("http://example.com/ns/geo", "location"), 
     fn.QName("http://example.com/ns/geo", "point"), 
     null, 
     ["collation=http://marklogic.com/collation/codepoint"]);
</pre></apidoc:example>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: 
   Get the co-occurrences of the "person" element with points encoded as
   "lat" and "long" children of "location" elements. Return the co-occurrences 
   as a sequence of XML nodes with frequencies.
:)
declare namespace geoex = "http://example.com/ns/geo"; 
 
cts:element-value-geospatial-co-occurrences( 
     xs:QName("geoex:person"), 
     xs:QName("geoex:location"), 
     xs:QName("geoex:lat"), 
     xs:QName("geoex:long"), 
     ("collation=http://marklogic.com/collation/codepoint"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   Get the co-occurrences of the "person" element with points encoded as
//   "lat" and "long" children of "location" elements. Return the 
//   co-occurrences as an ArrayNode with frequencies.

cts.elementValueGeospatialCoOccurrences( 
     fn.QName("http://example.com/ns/geo", "person"), 
     fn.QName("http://example.com/ns/geo", "location"), 
     fn.QName("http://example.com/ns/geo", "lat"), 
     fn.QName("http://example.com/ns/geo", "long"), 
     ["collation=http://marklogic.com/collation/codepoint"]);
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-geospatial-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Returns value co-occurrences from the specified element-attribute
  value lexicon with the specified geospatial lexicon.
  Value lexicons are implemented using range indexes;
  consequently this function requires a range index for the element and attribute
  pair specified in the function.
  If there is not a range index configured for the specified
  element and attribute pair, then an exception is thrown.
  Geospatial lexicons are implemented using geospatial indexes;
  consequently this function requires a geospatial index for the
  element/attribute combination specified in the function.
  If there is not a geospatial index configured for the specified
  element/attribute combination, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name-1" type="xs:QName">
    An element QName.
  </apidoc:param>
      <apidoc:param name="attribute-name-1" type="xs:QName?">
    An attribute QName.
  </apidoc:param>
      <apidoc:param name="geo-element-name" type="xs:QName">
    An element QName.
  </apidoc:param>
      <apidoc:param name="child-name-1" type="xs:QName?" optional="true">
    An element or attribute QName or empty sequence.
    The empty sequence specifies an element geospatial lexicon.
  </apidoc:param>
      <apidoc:param name="child-name-2" type="xs:QName?" optional="true">
    An element or attribute QName or empty sequence.
    The empty sequence specifies either an element lexicon or an
    element-child geospatial lexicon.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"geospatial-format=<em>format</em>"</dt>
        <dd>Use the kind of geospatial lexicon specified by <em>format</em>
        (element, element-child, element-pair, or element-attribute-pair).
        If neither of the child QNames is specified, the default is
        "element"; if only the first of the child QNames is specified,
        the default is "element-child:; if both child QNames are specified,
        the default is "element-pair".  If the selection is not compatible
        with the number of geospatial QNames specified, an error is raised.
        </dd>
        <dt>"ascending"</dt>
        <dd>Co-occurrences should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Co-occurrences should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Co-occurrences from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Co-occurrences from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Co-occurrences from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Co-occurrences from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Co-occurrences should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Co-occurrences should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included co-occurrences.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included co-occurrence.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>For the non-geospatial lexicon, use the type specified by
        <em>type</em> (int, unsignedInt, long, unsignedLong, float, double,
        decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay,
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>For the non-geospatial lexicon, use the collation specified by
        <em>URI</em>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>For the geospatial lexicons, use the coordinate system specified
        by <em>name</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date,
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"ordered"</dt>
        <dd>Include co-occurrences only when the value from the first lexicon
        appears before the value from the second lexicon.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"reversed"</dt>
        <dd>Consider the second lexicon as the first and vice versa.</dd>
        <dt>"proximity=<em>N</em>"</dt>
        <dd>Include co-occurrences only when the values appear within
        <em>N</em> words of each other.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> co-occurrences.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Co-occurrences from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a element(cts:co-occurrence)* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include co-occurrences in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included co-occurrences.
    The co-occurrences do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:co-occurrence)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "map" 
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all included co-occurrences may be returned.
  If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then co-occurrences from all fragments selected by the
  <code>$query</code> parameter are included.
  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: 
   Get the co-occurrences of the "person" element with points encoded as
   "lat" and "long" attributes of "location" elements. Return the 
   co-occurrences as a sequence of XML nodes with frequencies.
:)
declare namespace geoex = "http://example.com/ns/geo"; 
 
cts:element-attribute-value-geospatial-co-occurrences( 
     xs:QName("geoex:person"), 
     xs:QName("name"), 
     xs:QName("geoex:location"), 
     xs:QName("geoex:lat"), 
     xs:QName("geoex:long"), 
     ("collation=http://marklogic.com/collation/codepoint"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
//   Get the co-occurrences of the "name" attribute on the "person" element 
//   with points encoded as "lat" and "long" attributes of "location" 
//   elements. Return the co-occurrences as an ArrayNode with frequencies.

cts.elementAttributeValueGeospatialCoOccurrences( 
     fn.QName("http://example.com/ns/geo", "person"), 
     xs.QName("name"), 
     fn.QName("http://example.com/ns/geo", "location"), 
     fn.QName("http://example.com/ns/geo", "lat"), 
     fn.QName("http://example.com/ns/geo", "long"), 
     ["collation=http://marklogic.com/collation/codepoint"]);
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="geospatial-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Returns value co-occurrences from the geospatial lexicons.
  Geospatial lexicons are implemented using geospatial indexes;
  consequently this function requires a geospatial index for each
  combination of elements and attributes specified in the function.
  If there is not a geospatial index configured for the specified
  element/attribute combination, then an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="geo-element-name-1" type="xs:QName">
    An element QName.
  </apidoc:param>
      <apidoc:param name="child-1-name-1" type="xs:QName?">
    An element or attribute QName or empty sequence.
    The empty sequence specifies an element geospatial lexicon.
  </apidoc:param>
      <apidoc:param name="child-1-name-2" type="xs:QName?">
    An element or attribute QName or empty sequence.
    The empty sequence specifies either an element lexicon or an
    element-child geospatial lexicon.
  </apidoc:param>
      <apidoc:param name="geo-element-name-2" type="xs:QName">
    An element QName.
  </apidoc:param>
      <apidoc:param name="child-2-name-1" type="xs:QName?" optional="true">
    An element or attribute QName or empty sequence.
    The empty sequence specifies an element geospatial lexicon.
  </apidoc:param>
      <apidoc:param name="child-2-name-2" type="xs:QName?" optional="true">
    An element or attribute QName or empty sequence.
    The empty sequence specifies either an element lexicon or an
    element-child geospatial lexicon.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"geospatial-format=<em>format</em>"</dt>
        <dd>For both geospatial lexicons, use the kind of geospatial lexicon
        specified by <em>format</em>
        (element, element-child, element-pair, or element-attribute-pair).
        If neither of the child QNames is specified, the default is
        "element"; if only the first of the child QNames is specified,
        the default is "element-child:; if both child QNames are specified,
        the default is "element-pair".  If the selection is not compatible
        with the number of geospatial QNames specified, an error is raised.
        </dd>
        <dt>"geospatial-format-1=<em>format</em>"</dt>
        <dd>For the first geospatial lexicon, use the kind of geospatial lexicon
        specified by <em>format</em>
        (element, element-child, element-pair, or element-attribute-pair).
        If neither of the child QNames is specified, the default is
        "element"; if only the first of the child QNames is specified,
        the default is "element-child:; if both child QNames are specified,
        the default is "element-pair".  If the selection is not compatible
        with the number of geospatial QNames specified, an error is raised.
        </dd>
        <dt>"geospatial-format-2=<em>format</em>"</dt>
        <dd>For the second geospatial lexicons, use the kind of geospatial
        lexicon specified by <em>format</em>
        (element, element-child, element-pair, or element-attribute-pair).
        If neither of the child QNames is specified, the default is
        "element"; if only the first of the child QNames is specified,
        the default is "element-child:; if both child QNames are specified,
        the default is "element-pair".  If the selection is not compatible
        with the number of geospatial QNames specified, an error is raised.
        </dd>
        <dt>"ascending"</dt>
        <dd>Co-occurrences should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Co-occurrences should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Co-occurrences from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Co-occurrences from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Co-occurrences from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Co-occurrences from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Co-occurrences should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Co-occurrences should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included co-occurrences.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included co-occurrence.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"coordinate-system=<em>URI</em>"</dt>
        <dd>For both geospatial lexicons, use the coordinate system specified by
        <em>name</em>.</dd>
        <dt>"coordinate-system-1=<em>URI</em>"</dt>
        <dd>For the first geospatial lexicon, use the coordinate system
        specified by <em>name</em>.</dd>
        <dt>"coordinate-system-2=<em>URI</em>"</dt>
        <dd>For the second geospatial lexicons, use the coordinate system
        specified by <em>name</em>.</dd>
        <dt>"ordered"</dt>
        <dd>Include co-occurrences only when the value from the first lexicon
        appears before the value from the second lexicon.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"reversed"</dt>
        <dd>Consider the second lexicon as the first and vice versa.</dd>
        <dt>"proximity=<em>N</em>"</dt>
        <dd>Include co-occurrences only when the values appear within
        <em>N</em> words of each other.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> co-occurrences.</dd>
        <dt>"skip=<em>N</em>"</dt>
        <dd>Skip over fragments selected by the <code>cts:query</code>
        to treat the <em>Nth</em> matching fragment as the first fragment.
        Co-occurrences from skipped fragments are not included.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option does not affect the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only co-occurrences from the first <em>N</em>
        fragments after skip selected by the <code>cts:query</code>.
        This option affects the number of fragments selected
        by the <code>cts:query</code> to calculate frequencies.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"score-zero"</dt>
        <dd>Compute all scores as zero.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"too-many-positions-error"</dt>
        <dd>If too much memory is needed to perform positions calculations
        to check whether a document matches a query, 
        return an XDMP-TOOMANYPOSITIONS error, 
        instead of accepting the document as a match.</dd>
        <dt>"eager"</dt>
        <dd>Perform most of the work concurrently before returning
        the first item from the indexes, and only some of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a complete item-order 
        result or for any frequency-order result.</dd>
        <dt>"lazy"</dt>
        <dd>Perform only some the work concurrently before returning 
        the first item from the indexes, and most of the work
        sequentially while iterating through the rest of the items.
        This usually takes the shortest time for a small item-order 
        partial result.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon
        processing occurs.  This is especially useful in cases where multiple
        lexicon calls occur in the same query (for example, resolving many
        facets in a single query).</dd>
        <dt>"map"</dt>
	<dd>Return results as <span class="xquery">a single map:map 
	value instead of as a element(cts:co-occurrence)* sequence</span>
	<span class="javascript">a JavaScript Object instead of as 
	a ValueIterator</span>.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include co-occurrences in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>,
    and compute frequencies from this set of included co-occurrences.
    The co-occurrences do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as
    <a href="cts:search#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:co-occurrence)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified
  in the options parameter.  If neither "frequency-order" nor "item-order"
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified
  in the options parameter.  If neither "fragment-frequency" nor
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified
  in the options parameter.  If neither "ascending" nor "descending"
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "eager" or "lazy" may be specified
  in the options parameter.  If neither "eager" nor "lazy"
  is specified, then the default is "eager" if "frequency-order" or "map" 
  is specified, otherwise "lazy".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks"
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  "score-random", or "score-zero" options may be specified in the options
  parameter.
  If none of "score-logtfidf", "score-logtf", "score-simple", "score-random",
  or "score-zero" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter.
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "coordinate-system=<em>name</em>" is not specified in the options
  parameter, then the default coordinate system is used. If a lexicon with
  that coordinate system does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter,
  then all included co-occurrences may be returned.
  If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter,
  then co-occurrences from all fragments selected by the
  <code>$query</code> parameter are included.
  If a <code>$query</code> parameter is not present, then
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: 
   Get the co-occurrences of points encoded as "lat" and "long" children of
   "source" elements with points encoded as "lat" and "long" children of
   "destination" elements, where the source elements occur before the 
   destination elements in the document. Return the co-occurrences as a 
   map, where the key is the point from the first geospatial index and the 
   values are the points from the second geospatial index.
:)
declare namespace geoex = "http://example.com/ns/geo"; 
 
cts:geospatial-co-occurrences( 
     xs:QName("geoex:source"), 
     xs:QName("geoex:lat"), 
     xs:QName("geoex:long"), 
     xs:QName("geoex:destination"), 
     xs:QName("geoex:lat"), 
     xs:QName("geoex:long"), 
     ("ordered","map"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml"> 
//   Get the co-occurrences of points encoded as "lat" and "long" children of
//   "source" elements with points encoded as "lat" and "long" children of
//   "destination" elements, where the source elements occur before the 
//   destination elements in the document. Return the co-occurrences as a 
//   map, where the key is the point from the first geospatial index and the 
//   values are the points from the second geospatial index.

cts.geospatialCoOccurrences( 
     fn.QName("http://example.com/ns/geo", "source"), 
     fn.QName("http://example.com/ns/geo", "lat"), 
     fn.QName("http://example.com/ns/geo", "long"), 
     fn.QName("http://example.com/ns/geo", "destination"), 
     fn.QName("http://example.com/ns/geo", "lat"), 
     fn.QName("http://example.com/ns/geo", "long"), 
     ["ordered","map"]);
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="distance" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns the distance (in miles) between two points.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="p1" type="cts:point">
  The first point.
  </apidoc:param>
      <apidoc:param name="p2" type="cts:point">
  The second point.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options for the operation. The default is ().
  <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
  <blockquote xmlns="http://www.w3.org/1999/xhtml">
     <dl>
     <dt>"coordinate-system=wgs84"</dt>
     <dd>Use the WGS84 coordinate system.</dd>
     <dt>"units=miles"</dt>
     <dd>Distance is measured in miles.</dd>
     </dl>
   </blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $sf := cts:point(37, -122)
let $ny := cts:point(40, -73)
return
cts:distance($sf, $ny)

=&gt; 2623.2017796533
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var sf = cts.point(37, -122);
var ny = cts.point(40, -73);
cts.distance(sf, ny);

=&gt; 2623.2017796533
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="shortest-distance" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns the great circle distance (in miles) between a point and an
  region.  The region is defined by a <code xmlns="http://www.w3.org/1999/xhtml">cts:region</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="p1" type="cts:point">
  The first point.
  </apidoc:param>
      <apidoc:param name="region" type="cts:region+">
  A region such as a circle, box, polygon, linestring, or complex-polygon.
  For compatibility with previous versions, a sequence of points
  is interpreted as a sequence of arcs (defined pairwise) and the
  distance returned is the shortest distance to one of those points.
  If the first
  parameter is a point within the region specified in this parameter,
  then <code xmlns="http://www.w3.org/1999/xhtml">cts:shortest-distance</code> returns 0. If the point
  specified in the first parameter in not in the region specified in this
  parameter, then  <code xmlns="http://www.w3.org/1999/xhtml">cts:shortest-distance</code> returns the
  shortest distance to the boundary of the region.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options for the operation. The default is ().
  <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
  <blockquote xmlns="http://www.w3.org/1999/xhtml">
     <dl>
     <dt>"coordinate-system=wgs84"</dt>
     <dd>Use the WGS84 coordinate system.</dd>
     <dt>"units=miles"</dt>
     <dd>Distance is measured in miles.</dd>
     </dl>
   </blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:shortest-distance(
  cts:point(37.494965, -122.267654),
  cts:linestring((cts:point(40.720921, -74.008878),
                  cts:point(38.950224, -77.019714)))
)
=&gt; 2431.82739813132, which is the shortest distance (in miles)
   between San Carlos, CA and an arc between New York City and
   Washington DC.
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.shortestDistance(
  cts.point(37.494965, -122.267654),
  cts.linestring([cts.point(40.720921, -74.008878),
                  cts.point(38.950224, -77.019714)]);
)
=&gt; 2431.82739813132, which is the shortest distance (in miles)
   between San Carlos, CA and an arc between New York City and
   Washington DC.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="bearing" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns the true bearing in radians of the path from the first point
  to the second.  An error is raised if the two points are the same.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="p1" type="cts:point">
  The first point.
  </apidoc:param>
      <apidoc:param name="p2" type="cts:point">
  The second point.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options for the operation. The default is ().
  <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
  <blockquote xmlns="http://www.w3.org/1999/xhtml">
     <dl>
     <dt>"coordinate-system=wgs84"</dt>
     <dd>Use the WGS84 coordinate system.</dd>
     </dl>
   </blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $sf := cts:point(37, -122)
let $ny := cts:point(40, -73)
return
cts:bearing($sf, $ny)

=&gt; 1.22127859526251
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var sf = cts.point(37, -122);
var ny = cts.point(40, -73);
cts.bearing(sf, ny);

=&gt; 1.2212785952625
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="destination" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns the point at the given distance (in miles) along the given
  bearing (in radians) from the starting point.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="p" type="cts:point">
  The starting point.
  </apidoc:param>
      <apidoc:param name="bearing" type="xs:double">
  The bearing, in radians.
  </apidoc:param>
      <apidoc:param name="distance" type="xs:double">
  The distance, in miles.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options for the operation. The default is ().
  <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
  <blockquote xmlns="http://www.w3.org/1999/xhtml">
     <dl>
     <dt>"coordinate-system=wgs84"</dt>
     <dd>Use the WGS84 coordinate system.</dd>
     <dt>"units=miles"</dt>
     <dd>Distance is measured in miles.</dd>
     </dl>
   </blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $sf := cts:point(37, -122)
let $ny := cts:point(40, -73)
return
cts:destination($sf, 1.22100904274442,
    cts:distance($sf, $ny))

=&gt;
cts:point("40.009335,-72.997467")
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var sf = cts.point(37, -122);
var ny = cts.point(40, -73);
cts.destination(sf, 1.22100904274442,
    cts.distance(sf, ny));

=&gt;
cts:point("40.009335,-72.997467")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="arc-intersection" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns the point at the intersection of two arcs. If the arcs do
  not intersect, or lie on the same great circle, or if either arc covers
  more than 180 degrees, an error is raised.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="p1" type="cts:point">
  The starting point of the first arc.
  </apidoc:param>
      <apidoc:param name="p2" type="cts:point">
  The ending point of the first arc.
  </apidoc:param>
      <apidoc:param name="q1" type="cts:point">
  The starting point of the second arc.
  </apidoc:param>
      <apidoc:param name="q2" type="cts:point">
  The ending point of the second arc.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options for the operation. The default is ().
  <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
  <blockquote xmlns="http://www.w3.org/1999/xhtml">
     <dl>
     <dt>"coordinate-system=wgs84"</dt>
     <dd>Use the WGS84 coordinate system.</dd>
     </dl>
   </blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $sf := cts:point(37, -122)
let $ny := cts:point(40, -73)
let $a := cts:point(35,-100)
let $b := cts:point(41,-70)
return
cts:arc-intersection($sf,$ny,$a,$b)

=&gt; 40.458347,-76.203682
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var sf = cts.point(37, -122);
var ny = cts.point(40, -73)
var a = cts.point(35,-100)
var b = cts.point(41,-70)
cts.arcIntersection(sf, ny, a, b);

=&gt; 40.458347,-76.203682
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="box-intersects" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns true if the box intersects with a region.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="box" type="cts:box">
  A geographic box.
  </apidoc:param>
      <apidoc:param name="region" type="cts:region*">
    One or more geographic regions (boxes, circles, polygons, or points).
    Where multiple regions are specified, return true if any region intersects
    the box.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options for the operation. The default is ().
  <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are counted as
        matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are not 
	counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
      </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Does the lat-long box between Greenwich and Edinburgh intersect with
  a 10 mile circle around Birmingham? Yes. :)
cts:box-intersects(
  cts:box(51.48, -3.188889, 55.953056, 0.0),
  cts:circle(10, cts:point(52.483056, -1.893611))) 
=&gt; true
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Does the lat-long box between Greenwich and Edinburgh intersect with
// a 10 mile circle around Birmingham? Yes. 
cts.boxIntersects(
  cts.box(51.48, -3.188889, 55.953056, 0.0),
  cts.circle(10, cts.point(52.483056, -1.893611))); 
=&gt; true
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="circle-intersects" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns true if the circle intersects with a region.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="circle" type="cts:circle">
  A geographic circle.
  </apidoc:param>
      <apidoc:param name="region" type="cts:region*">
    One or more geographic regions (boxes, circles, polygons, or points).
    Where multiple regions are specified, return true if any region intersects
    the target circle.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options for the operation. The default is ().
  <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are counted as
        matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are not 
	counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
      </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Is the Greenwich Observatory within a mile of the A2 Blackheath Road? Yes.
 :)
cts:circle-intersects(
  cts:circle(1, cts:point(51.48,0)),
  cts:linestring((
    cts:point(51.4745404, -0.0238609),
    cts:point(51.4742464, -0.0212431),
    cts:point(51.4731772, -0.0186682),
    cts:point(51.4729901, -0.0151920),
    cts:point(51.4722950, -0.0132608),
    cts:point(51.4727495, -0.0084972),
    cts:point(51.4718139, -0.0015020),
    cts:point(51.4728029, 0.0095701),
    cts:point(51.4747810, 0.0241184))))

==&gt; true
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Is the Greenwich Observatory within a mile of the A2 Blackheath Road? Yes.
 
cts.circleIntersects(
  cts.circle(1, cts.point(51.48,0)),
  cts.linestring([
    cts.point(51.4745404, -0.0238609),
    cts.point(51.4742464, -0.0212431),
    cts.point(51.4731772, -0.0186682),
    cts.point(51.4729901, -0.0151920),
    cts.point(51.4722950, -0.0132608),
    cts.point(51.4727495, -0.0084972),
    cts.point(51.4718139, -0.0015020),
    cts.point(51.4728029, 0.0095701),
    cts.point(51.4747810, 0.0241184)]));

==&gt; true
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="polygon-intersects" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns true if the polygon intersects with a region.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="polygon" type="cts:polygon">
  A geographic polygon.
  </apidoc:param>
      <apidoc:param name="region" type="cts:region*">
    One or more geographic regions (boxes, circles, polygons, or points).
    Where multiple regions are specified, return true if any region intersects
    the target polygon.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options for the operation. The default is ().
  <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are counted
        as matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are not 
	counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
      </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Is Regent's Park within a mile of the American School in London? Yes :)
cts:polygon-intersects(
    cts:polygon((
      cts:point(51.5298921,-0.1674557),
      cts:point(51.5327487,-0.1660395),
      cts:point(51.5343504,-0.1644945),
      cts:point(51.5354716,-0.1620483),
      cts:point(51.5367796,-0.1574993),
      cts:point(51.5374737,-0.1526499),
      cts:point(51.5369398,-0.1488304),
      cts:point(51.5351513,-0.1468134),
      cts:point(51.5319478,-0.1460838),
      cts:point(51.5284771,-0.1460409),
      cts:point(51.5253265,-0.1455688),
      cts:point(51.5237779,-0.1450968),
      cts:point(51.5227899,-0.1461697),
      cts:point(51.5233507,-0.1478004),
      cts:point(51.5246323,-0.1483583),
      cts:point(51.5248192,-0.1587868),
      cts:point(51.5266348,-0.1604605),
      cts:point(51.5292514,-0.1644945),
      cts:point(51.5298387,-0.1665545)
    )),
	cts:circle(1,cts:point(51.5347842,-0.1766932)))
==&gt; true

</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Is Regent's Park within a mile of the American School in London? Yes 

cts.polygonIntersects(
    cts.polygon([
      cts.point(51.5298921,-0.1674557),
      cts.point(51.5327487,-0.1660395),
      cts.point(51.5343504,-0.1644945),
      cts.point(51.5354716,-0.1620483),
      cts.point(51.5367796,-0.1574993),
      cts.point(51.5374737,-0.1526499),
      cts.point(51.5369398,-0.1488304),
      cts.point(51.5351513,-0.1468134),
      cts.point(51.5319478,-0.1460838),
      cts.point(51.5284771,-0.1460409),
      cts.point(51.5253265,-0.1455688),
      cts.point(51.5237779,-0.1450968),
      cts.point(51.5227899,-0.1461697),
      cts.point(51.5233507,-0.1478004),
      cts.point(51.5246323,-0.1483583),
      cts.point(51.5248192,-0.1587868),
      cts.point(51.5266348,-0.1604605),
      cts.point(51.5292514,-0.1644945),
      cts.point(51.5298387,-0.1665545)
    ]),
	cts.circle(1,cts.point(51.5347842,-0.1766932)));
==&gt; true

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="polygon-contains" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns true if the polygon contains a region.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="polygon" type="cts:polygon">
  A geographic polygon.
  </apidoc:param>
      <apidoc:param name="region" type="cts:region*">
    One or more geographic regions (boxes, circles, polygons, or points).
    Where multiple regions are specified, return true if any region contains
    the target polygon.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options for the operation. The default is ().
  <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are counted
        as matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are not 
	counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
      </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Is the London Zoo in Regent's Park? Yes :)
cts:polygon-contains(
    cts:polygon((
      cts:point(51.5298921,-0.1674557),
      cts:point(51.5327487,-0.1660395),
      cts:point(51.5343504,-0.1644945),
      cts:point(51.5354716,-0.1620483),
      cts:point(51.5367796,-0.1574993),
      cts:point(51.5374737,-0.1526499),
      cts:point(51.5369398,-0.1488304),
      cts:point(51.5351513,-0.1468134),
      cts:point(51.5319478,-0.1460838),
      cts:point(51.5284771,-0.1460409),
      cts:point(51.5253265,-0.1455688),
      cts:point(51.5237779,-0.1450968),
      cts:point(51.5227899,-0.1461697),
      cts:point(51.5233507,-0.1478004),
      cts:point(51.5246323,-0.1483583),
      cts:point(51.5248192,-0.1587868),
      cts:point(51.5266348,-0.1604605),
      cts:point(51.5292514,-0.1644945),
      cts:point(51.5298387,-0.1665545)
    )),
    cts:polygon((
      cts:point(51.5361190,-0.1590335),
      cts:point(51.5366529,-0.1568234),
      cts:point(51.5372001,-0.1537657),
      cts:point(51.5372868,-0.1527464),
      cts:point(51.5334561,-0.1509440),
      cts:point(51.5332359,-0.1517808),
      cts:point(51.5348643,-0.1584756),
      cts:point(51.5355250,-0.1592481),
      cts:point(51.5360522,-0.1590765)
  )))
==&gt; true
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Is the London Zoo in Regent's Park? Yes 

cts.polygonContains(
    cts.polygon([
      cts.point(51.5298921,-0.1674557),
      cts.point(51.5327487,-0.1660395),
      cts.point(51.5343504,-0.1644945),
      cts.point(51.5354716,-0.1620483),
      cts.point(51.5367796,-0.1574993),
      cts.point(51.5374737,-0.1526499),
      cts.point(51.5369398,-0.1488304),
      cts.point(51.5351513,-0.1468134),
      cts.point(51.5319478,-0.1460838),
      cts.point(51.5284771,-0.1460409),
      cts.point(51.5253265,-0.1455688),
      cts.point(51.5237779,-0.1450968),
      cts.point(51.5227899,-0.1461697),
      cts.point(51.5233507,-0.1478004),
      cts.point(51.5246323,-0.1483583),
      cts.point(51.5248192,-0.1587868),
      cts.point(51.5266348,-0.1604605),
      cts.point(51.5292514,-0.1644945),
      cts.point(51.5298387,-0.1665545)
    ]),
    cts.polygon([
      cts.point(51.5361190,-0.1590335),
      cts.point(51.5366529,-0.1568234),
      cts.point(51.5372001,-0.1537657),
      cts.point(51.5372868,-0.1527464),
      cts.point(51.5334561,-0.1509440),
      cts.point(51.5332359,-0.1517808),
      cts.point(51.5348643,-0.1584756),
      cts.point(51.5355250,-0.1592481),
      cts.point(51.5360522,-0.1590765)
  ]));
=&gt; true
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="complex-polygon-intersects" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns true if the complex-polygon intersects with a region.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="complex-polygon" type="cts:complex-polygon">
  A geographic complex-polygon.
  </apidoc:param>
      <apidoc:param name="region" type="cts:region*">
    One or more geographic regions (boxes, circles, complex-polygons, or 
    points).
    Where multiple regions are specified, return true if any region intersects
    the target complex-polygon.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options for the operation. The default is ().
  <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and complex-polygons' boundaries are
        counted as matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and complex-polygons' boundaries are 
	not counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
      </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $cp := cts:complex-polygon(
  cts:polygon("0,0 10,0 10,10 0,10 0,0"),
  cts:polygon("5,0 7,0 7,5 5,5 5,0"))
let $reg := cts:box(51.48, -3.188889, 55.953056, 0.0)
return
cts:complex-polygon-intersects($cp, $reg)
=&gt;
false
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var cp = cts.complexPolygon(
  cts.polygon("0,0 10,0 10,10 0,10 0,0"),
  cts.polygon("5,0 7,0 7,5 5,5 5,0"));
var reg = cts.box(51.48, -3.188889, 55.953056, 0.0)
cts.complexPolygonIntersects(cp, reg);
=&gt;
false
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="complex-polygon-contains" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns true if the complex-polygon contains a region.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="complex-polygon" type="cts:complex-polygon">
  A geographic complex polygon.
  </apidoc:param>
      <apidoc:param name="region" type="cts:region*">
    One or more geographic regions (boxes, circles, polygons, or points).
    Where multiple regions are specified, return true if any region intersects
    the target polygon.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options for the operation. The default is ().
  <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and complex-polygons' boundaries are
        counted as matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and complex-polygons' boundaries are 
	not counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
      </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $cp :=
  cts:complex-polygon(
    cts:polygon("0,0 10,0 10,10 0,10 0,0"),
    cts:polygon("5,0 7,0 7,5 5,5 5,0"))
let $poly :=
  cts:polygon("6,8 6.5,8 6.5,9 6,9 6,8")
return cts:complex-polygon-contains($cp, $poly)
(: returns true :)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var cp =
  cts.complexPolygon(
    cts.polygon("0,0 10,0 10,10 0,10 0,0"),
    cts.polygon("5,0 7,0 7,5 5,5 5,0"));
var poly =
  cts.polygon("6,8 6.5,8 6.5,9 6,9 6,8");
cts.complexPolygonContains(cp, poly);
// returns true 
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="region-intersects" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns true if the target region intersects with a region.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="target" type="cts:region">
  A geographic region (box, circle, polygon, or point).
  </apidoc:param>
      <apidoc:param name="region" type="cts:region*">
    One or more geographic regions.
    Where multiple regions are specified, return true if any region intersects
    the target region.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options for the operation. The default is ().
  <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on regions' boundaries are counted as matching.
        This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on regions' boundaries are not counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
      </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Is the Greenwich Observatory within a mile of the A2 Blackheath Road? Yes.
 :)
cts:region-intersects(
  cts:circle(1, cts:point(51.48,0)),
  cts:linestring((
    cts:point(51.4745404, -0.0238609),
    cts:point(51.4742464, -0.0212431),
    cts:point(51.4731772, -0.0186682),
    cts:point(51.4729901, -0.0151920),
    cts:point(51.4722950, -0.0132608),
    cts:point(51.4727495, -0.0084972),
    cts:point(51.4718139, -0.0015020),
    cts:point(51.4728029, 0.0095701),
    cts:point(51.4747810, 0.0241184))))

==&gt; true
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Is the Greenwich Observatory within a mile of the A2 Blackheath Road? Yes.
 
cts.regionIntersects(
  cts.circle(1, cts.point(51.48,0)),
  cts.linestring([
    cts.point(51.4745404, -0.0238609),
    cts.point(51.4742464, -0.0212431),
    cts.point(51.4731772, -0.0186682),
    cts.point(51.4729901, -0.0151920),
    cts.point(51.4722950, -0.0132608),
    cts.point(51.4727495, -0.0084972),
    cts.point(51.4718139, -0.0015020),
    cts.point(51.4728029, 0.0095701),
    cts.point(51.4747810, 0.0241184)]));

==&gt; true
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="region-contains" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns true if one region contains the other region.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="region" type="cts:region">
  A geographic region.
  </apidoc:param>
      <apidoc:param name="region" type="cts:region*">
    One or more geographic regions (boxes, circles, polygons, or points).
    Where multiple regions are specified, return true if any region intersects
    the target polygon.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options for the operation. The default is ().
  <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and regions' boundaries are counted as
        matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and regions' boundaries are not 
	counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
      </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Does the lat-long box between Greenwich and Edinburgh contain the
   10 mile circle around Birmingham? Yes. :)
cts:region-contains(
  cts:box(51.48, -3.188889, 55.953056, 0.0),
  cts:circle(10, cts:point(52.483056, -1.893611))) 
=&gt; true
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Does the lat-long box between Greenwich and Edinburgh contain the
// 10 mile circle around Birmingham? Yes. 

cts.regionContains(
  cts.box(51.48, -3.188889, 55.953056, 0.0),
  cts.circle(10, cts.point(52.483056, -1.893611))); 
=&gt; true
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="bounding-boxes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a sequence of boxes that bound the given region.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="region" type="cts:region">
  A geographic region (box, circle, polygon, or point).
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
  Options for the operation. The default is ().
  <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
    <p xmlns="http://www.w3.org/1999/xhtml">Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml">
        <dl>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"units=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        <dt>"box-percent=n"</dt>
        <dd>An integer between 0 and 100 (default is 100) that indicates what
        percentage of a polygon's bounding box slivers should be returned.
        Lower numbers give fewer, less accurate boxes; larger numbers give
        more, more accurate boxes.</dd>
        <dt>"boundaries-included"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are counted as
        matching.  This is the default.</dd>
        <dt>"boundaries-excluded"</dt>
        <dd>Points on boxes', circles', and polygons' boundaries are not 
	counted as matching.</dd>
        <dt>"boundaries-latitude-excluded"</dt>
        <dd>Points on boxes' latitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-longitude-excluded"</dt>
        <dd>Points on boxes' longitude boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-south-excluded"</dt>
        <dd>Points on the boxes' southern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-west-excluded"</dt>
        <dd>Points on the boxes' western boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-north-excluded"</dt>
        <dd>Points on the boxes' northern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-east-excluded"</dt>
        <dd>Points on the boxes' eastern boundaries are not counted as 
	matching.</dd>
        <dt>"boundaries-circle-excluded"</dt>
        <dd>Points on circles' boundary are not counted as matching.</dd>
      </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:box*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:bounding-boxes(
  cts:polygon("0,0 20,20 -10,18 5,5 0,0")
)
(: Returns two boxes:
   [-10, 0, 5, 18.976505]
   [5, 4.7157488, 20, 20]
:)
;
cts:bounding-boxes(
  cts:polygon("0,0 20,20 -10,18 5,5 0,0"),
  "box-percent=50"
)
(: Returns one box:
   [-10, 0, 20, 20]
:)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.boundingBoxes(
  cts.polygon("0,0 20,20 -10,18 5,5 0,0")
);
// Returns two boxes:
//   [-10, 0, 5, 18.976505]
//   [5, 4.7157488, 20, 20]

**************
cts.boundingBoxes(
  cts.polygon("0,0 20,20 -10,18 5,5 0,0"),
  "box-percent=50"
);
// Returns one box:
//   [-10, 0, 20, 20]

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="parse-wkt" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a sequence of geospatial regions parsed from Well-Known Text format.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="wtk" type="xs:string*">
    A sequence of strings in Well-Known Text format.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:region*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $node :=
    &lt;complexPolygon name="Arapahoe"&gt;POLYGON((
      0.396982870000000E+02 -0.104935135000000E+03,
      0.396965870000000E+02 -0.104938635000000E+03,
      0.396965870000000E+02 -0.104938635000000E+03,
      0.397110870000000E+02 -0.104931634000000E+03,
      0.397066870000000E+02 -0.104926934000000E+03,
      0.397012870000000E+02 -0.104932834000000E+03,
      0.396971870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104931534000000E+03,
      0.396966870000000E+02 -0.104934335000000E+03,
      0.396966870000000E+02 -0.104934335000000E+03,
      0.396981250000000E+02 -0.104934109000000E+03
      ),
       (
      0.396981250000000E+02 -0.104934109000000E+03,
      0.397001130000000E+02 -0.104931652000000E+03,
      0.397001870000000E+02 -0.104934034000000E+03,
      0.396981250000000E+02 -0.104934109000000E+03
       ))
    &lt;/complexPolygon&gt;
    return
    cts:parse-wkt(fn:data($node))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
var node = {Arapahoe:"POLYGON(( \n\
            0.396982870000000E+02 -0.104935135000000E+03, \n\
            0.396965870000000E+02 -0.104938635000000E+03, \n\
            0.396965870000000E+02 -0.104938635000000E+03, \n\
            0.397110870000000E+02 -0.104931634000000E+03, \n\
            0.397066870000000E+02 -0.104926934000000E+03, \n\
            0.397012870000000E+02 -0.104932834000000E+03, \n\
            0.396971870000000E+02 -0.104928134000000E+03, \n\
            0.396965870000000E+02 -0.104928134000000E+03, \n\
            0.396965870000000E+02 -0.104928134000000E+03, \n\
            0.396965870000000E+02 -0.104931534000000E+03, \n\
            0.396966870000000E+02 -0.104934335000000E+03, \n\
            0.396966870000000E+02 -0.104934335000000E+03, \n\
            0.396981250000000E+02 -0.104934109000000E+03), \n\
            ( 0.396981250000000E+02 -0.104934109000000E+03, \n\
            0.397001130000000E+02 -0.104931652000000E+03, \n\
            0.397001870000000E+02 -0.104934034000000E+03, \n\
            0.396981250000000E+02 -0.104934109000000E+03))"};
cts.parseWkt(node.Arapahoe);
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="to-wkt" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
  Returns a sequence of strings in Well-Known Text format.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="wtk" type="cts:region*">
    A sequence of geospatial regions.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

cts:to-wkt(cts:point(36, 71))
=&gt;
POINT(71 36)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.toWkt(cts.point(36, 71));
=&gt;
POINT(71 36)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="geospatial-element-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Creates a reference to a geospatial element range index, for use as a
  parameter to cts:value-tuples. This function will throw an exception if the
  specified range index does not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element" type="xs:QName">
    An element name.</apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options. The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (point or long-lat-point)</dd>
        <dt>"coordinate-system=<em>coord</em>"</dt>
        <dd>Use the given coordinate system. Possible values
        are "wgs84" and "raw".</dd>
        <dt>"nullable"</dt>
        <dd>Allow null values in tuples reported from cts:value-tuples when
        using this lexicon.</dd>
        <dt>"unchecked"</dt>
        <dd>Read the scalar type and coordinate-system info
        only from the input. Do not check the definition against the
        context database.</dd>
     </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:geospatial-element-reference(xs:QName("point"))
=&gt;
cts:geospatial-element-reference(fn:QName("","point"),
  ("type=point","coordinate-system=wgs84"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.geospatialElementReference(xs.QName("point"));
=&gt;
cts.geospatialElementReference(fn.QName("","point"), 
  ["type=point","coordinate-system=wgs84"])
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="geospatial-json-property-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Creates a reference to a geospatial json property range index, for use as a
  parameter to cts:value-tuples. This function will throw an exception if the
  specified range index does not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="property" type="xs:string">
    A JSON property name.</apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options. The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (point or long-lat-point)</dd>
        <dt>"coordinate-system=<em>coord</em>"</dt>
        <dd>Use the given coordinate system. Possible values
        are "wgs84" and "raw".</dd>
        <dt>"nullable"</dt>
        <dd>Allow null values in tuples reported from cts:value-tuples when
        using this lexicon.</dd>
        <dt>"unchecked"</dt>
        <dd>Read the scalar type and coordinate-system info
        only from the input. Do not check the definition against the
        context database.</dd>
     </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:geospatial-json-property-reference("point")
=&gt;
cts:geospatial-json-property-reference("point", ("type=point","coordinate-system=wgs84"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.geospatialJsonPropertyReference("point")
=&gt;
cts.geospatialJsonPropertyReference("point", ["type=point","coordinate-system=wgs84"])
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="geospatial-element-child-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Creates a reference to a geospatial element child range index, for use as a
  parameter to cts:value-tuples. This function will throw an exception if the
  specified range index does not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element" type="xs:QName">
    An element QName name.</apidoc:param>
      <apidoc:param name="child" type="xs:QName">
    An element QName name.</apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (point or long-lat-point)</dd>
        <dt>"coordinate-system=<em>coord</em>"</dt>
        <dd>Use the given coordinate system. Possible values
        are "wgs84" and "raw".</dd>
        <dt>"nullable"</dt>
        <dd>Allow null values in tuples reported from cts:value-tuples when
        using this lexicon.</dd>
        <dt>"unchecked"</dt>
        <dd>Read the scalar type and coordinate-system info
        only from the input. Do not check the definition against the
        context database.</dd>
     </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:geospatial-element-child-reference(xs:QName("location"), xs:QName("point"))
=&gt;
cts:geospatial-element-child-reference(fn:QName("","location"), 
  fn:QName("","point"), ("type=point","coordinate-system=wgs84"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.geospatialElementChildReference(xs.QName("location"), xs.QName("point"));
=&gt;
cts.geospatialElementChildReference(fn.QName("","location"), 
  fn.QName("","point"), ["type=point","coordinate-system=wgs84"])
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="geospatial-json-property-child-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Creates a reference to a geospatial json property child range index, for use as a
  parameter to cts:value-tuples. This function will throw an exception if the
  specified range index does not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="property" type="xs:string">
    A JSON property name.</apidoc:param>
      <apidoc:param name="child" type="xs:string">
    A JSON property name.</apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (point or long-lat-point)</dd>
        <dt>"coordinate-system=<em>coord</em>"</dt>
        <dd>Use the given coordinate system. Possible values
        are "wgs84" and "raw".</dd>
        <dt>"nullable"</dt>
        <dd>Allow null values in tuples reported from cts:value-tuples when
        using this lexicon.</dd>
        <dt>"unchecked"</dt>
        <dd>Read the scalar type and coordinate-system info
        only from the input. Do not check the definition against the
        context database.</dd>
     </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:geospatial-json-property-child-reference("location", "point")
=&gt;
cts:geospatial-json-property-child-reference("location", "point", ("type=point","coordinate-system=wgs84"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.geospatialJsonPropertyChildReference("location", "point")
=&gt;
cts.geospatialJsonPropertyChildReference("location", "point", ["type=point","coordinate-system=wgs84"])
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="geospatial-element-pair-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Creates a reference to a geospatial element pair range index, for use as a
  parameter to cts:value-tuples. This function will throw an exception if the
  specified range index does not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element" type="xs:QName">
    An element QName name.</apidoc:param>
      <apidoc:param name="lat" type="xs:QName">
    An element QName name.</apidoc:param>
      <apidoc:param name="long" type="xs:QName">
    An element QName name.</apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (point or long-lat-point)</dd>
        <dt>"coordinate-system=<em>coord</em>"</dt>
        <dd>Use the given coordinate system. Possible values
        are "wgs84" and "raw".</dd>
        <dt>"nullable"</dt>
        <dd>Allow null values in tuples reported from cts:value-tuples when
        using this lexicon.</dd>
        <dt>"unchecked"</dt>
        <dd>Read the scalar type and coordinate-system info
        only from the input. Do not check the definition against the
        context database.</dd>
     </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:geospatial-element-pair-reference(xs:QName("pt"), xs:QName("lat"),
  xs:QName("long"))
=&gt;
cts:geospatial-element-pair-reference(fn:QName("","pt"), fn:QName("","lat"),
  fn:QName("","long"), ("type=point","coordinate-system=wgs84"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.geospatialElementPairReference(xs.QName("pt"), xs.QName("lat"),
  xs.QName("long"));
=&gt;
cts.geospatialElementPairReference(fn:QName("","pt"), fn.QName("","lat"),
  fn.QName("","long"), ["type=point","coordinate-system=wgs84"])
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="geospatial-json-property-pair-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Creates a reference to a geospatial JSON property pair range index, for use as a
  parameter to cts:value-tuples. This function will throw an exception if the
  specified range index does not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="property" type="xs:string">
    A JSON property name.</apidoc:param>
      <apidoc:param name="lat" type="xs:string">
    A JSON property name.</apidoc:param>
      <apidoc:param name="long" type="xs:string">
    A JSON property name.</apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (point or long-lat-point)</dd>
        <dt>"coordinate-system=<em>coord</em>"</dt>
        <dd>Use the given coordinate system. Possible values
        are "wgs84" and "raw".</dd>
        <dt>"nullable"</dt>
        <dd>Allow null values in tuples reported from cts:value-tuples when
        using this lexicon.</dd>
        <dt>"unchecked"</dt>
        <dd>Read the scalar type and coordinate-system info
        only from the input. Do not check the definition against the
        context database.</dd>
     </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:geospatial-json-property-pair-reference("pt", "lat", "long")
=&gt;
cts:geospatial-json-property-pair-reference("pt", lat", "long",
  ("type=point","coordinate-system=wgs84"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.geospatialJsonPropertyPairReference("pt", "lat", "long")
=&gt;
cts.geospatialJsonPropertyPairReference("pt", lat", "long",
  ["type=point","coordinate-system=wgs84"])
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="geospatial-attribute-pair-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Creates a reference to a geospatial attribute pair range index, for use as a
  parameter to cts:value-tuples. This function will throw an exception if the
  specified range index does not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element" type="xs:QName">
    An element QName name.</apidoc:param>
      <apidoc:param name="lat" type="xs:QName">
    An attribute QName name.</apidoc:param>
      <apidoc:param name="long" type="xs:QName">
    An attribute QName name.</apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (point or long-lat-point)</dd>
        <dt>"coordinate-system=<em>coord</em>"</dt>
        <dd>Use the given coordinate system. Possible values
        are "wgs84" and "raw".</dd>
        <dt>"nullable"</dt>
        <dd>Allow null values in tuples reported from cts:value-tuples when
        using this lexicon.</dd>
        <dt>"unchecked"</dt>
        <dd>Read the scalar type and coordinate-system info
        only from the input. Do not check the definition against the
        context database.</dd>
     </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:geospatial-attribute-pair-reference(xs:QName("pt"),
  xs:QName("lat"), xs:QName("long"))
=&gt;
cts:geospatial-attribute-pair-reference(fn:QName("","pt"),
  fn:QName("","lat"), fn:QName("","long"),
  ("type=point","coordinate-system=wgs84"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.geospatialAttributePairReference(xs.QName("pt"),
  xs.QName("lat"), xs.QName("long"));
=&gt;
cts.geospatialAttributePairReference(fn.QName("","pt"),
  fn.QName("","lat"), fn.QName("","long"),
  ["type=point","coordinate-system=wgs84"])
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="geospatial-path-reference" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon">
    <apidoc:summary>
  Creates a reference to a geospatial path range index, for use as a
  parameter to cts:value-tuples. This function will throw an exception if the
  specified range index does not exist.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="path-expression" type="xs:string">
    A path expression.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em>
        (point or long-lat-point)</dd>
        <dt>"coordinate-system=<em>coord</em>"</dt>
        <dd>Use the given coordinate system. Possible values
        are "wgs84" and "raw".</dd>
        <dt>"nullable"</dt>
        <dd>Allow null values in tuples reported from cts:value-tuples when
        using this lexicon.</dd>
        <dt>"unchecked"</dt>
        <dd>Read the scalar type and coordinate-system info
        only from the input. Do not check the definition against the
        context database.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="map" type="map:map" optional="true">
  A map of namespace bindings. The keys should be namespace prefixes and the
  values should be namespace URIs. These namespace bindings will be added to
  the in-scope namespace bindings in the interpretation of the path.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:reference</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:geospatial-path-reference("//item/point")
=&gt;
cts:geospatial-path-reference("//item/point",
  ("type=point","coordinate-system=wgs84"))
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts.geospatialPathReference("//item/point");
=&gt;
cts.geospatialPathReference("//item/point",
   ["type=point","coordinate-system=wgs84"])
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="approx-center" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial">
    <apidoc:summary>
   Return a point approximating the center of the given region.
   For a point, this is the point itself.
   For a circle, it is the center point.
   For a box, it is the point whose latitude is half-way between the northern
   and southern limits and whose longitude is half-way between the western and
   eastern limits.
   For polygons, complex polygons, and linestrings, an approximate centroid
   is returned. This approximation is rough, and useful for quick comparisons.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="region" type="cts:region">
    A geospatial region.</apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"box-percent=n"</dt>
        <dd>An integer between 0 and 100 (default is 100) that indicates what
        percentage of a polygon's bounding box slivers should be used in
        constructing the approximate centroid.  Lower numbers use fewer
        slivers, giving faster but less accurate results; larger numbers use
        more slivers, giving slower but more accurate results.
        </dd>
        <dt>"coordinate-system=wgs84"</dt>
        <dd>Use the WGS84 coordinate system.</dd>
        <dt>"coordinate-system=raw"</dt>
        <dd>Use the raw coordinate system.</dd>
     </dl></blockquote>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:point</apidoc:return>
    <apidoc:example class="xquery"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Approximate center of London Zoo :)
cts:approx-center(
    cts:polygon((
      cts:point(51.5361190,-0.1590335),
      cts:point(51.5366529,-0.1568234),
      cts:point(51.5372001,-0.1537657),
      cts:point(51.5372868,-0.1527464),
      cts:point(51.5334561,-0.1509440),
      cts:point(51.5332359,-0.1517808),
      cts:point(51.5348643,-0.1584756),
      cts:point(51.5355250,-0.1592481),
      cts:point(51.5360522,-0.1590765)
  )))

==&gt; cts:point(51.535511,-0.15516526)
</pre></apidoc:example>
    <apidoc:example class="javascript"><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
// Approximate center of London Zoo 
cts.approxCenter(
    cts.polygon([
      cts.point(51.5361190,-0.1590335),
      cts.point(51.5366529,-0.1568234),
      cts.point(51.5372001,-0.1537657),
      cts.point(51.5372868,-0.1527464),
      cts.point(51.5334561,-0.1509440),
      cts.point(51.5332359,-0.1517808),
      cts.point(51.5348643,-0.1584756),
      cts.point(51.5355250,-0.1592481),
      cts.point(51.5360522,-0.1590765)
  ]));

==&gt; cts.point(51.535511,-0.15516526)
</pre></apidoc:example>
  </apidoc:function></apidoc:module>